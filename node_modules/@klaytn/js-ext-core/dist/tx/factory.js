"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.parseTransaction = exports.KlaytnTxFactory = exports.KlaytnTx = void 0;
const transactions_1 = require("@ethersproject/transactions");
const field_1 = require("../field");
const util_1 = require("../util");
function getTypePrefix(rlp) {
    if (!util_1.HexStr.isHex(rlp)) {
        throw new Error("Not an RLP encoded string");
    }
    if (rlp.length < 4) {
        throw new Error("RLP encoded string too short");
    }
    return util_1.HexStr.toNumber(rlp.substring(0, 4)); // 0xNN
}
class KlaytnTx extends field_1.FieldSet {
    // //////////////////////////////////////////////////////////
    // Child classes MAY override below methods
    // RLP encoding for fee payer to sign.
    sigFeePayerRLP() {
        if (!(0, util_1.isFeePayerSigTxType)(this.type)) {
            this.throwTypeError("sigFeePayerRLP not defined");
        }
        else {
            this.throwTypeError("sigFeePayerRLP not implemented");
        }
    }
    // RLP encoding with sender signature.
    senderTxHashRLP() {
        if (!(0, util_1.isFeePayerSigTxType)(this.type)) {
            return this.txHashRLP();
        }
        else {
            this.throwTypeError("senderTxHashRLP not implemented");
        }
    }
    // //////////////////////////////////////////////////////////
    // Child classes CANNOT override below methods
    throwTypeError(msg) {
        throw new Error(`${msg} for '${this.typeName}' (type ${util_1.HexStr.fromNumber(this.type)})`);
    }
    // Add a signature
    addSenderSig(sig) {
        var _a;
        const tuple = (0, util_1.getSignatureTuple)(sig);
        (_a = this.fields).txSignatures || (_a.txSignatures = []);
        this.fields.txSignatures.push(tuple);
    }
    // Add a signature as a feePayer
    addFeePayerSig(sig) {
        var _a;
        const tuple = (0, util_1.getSignatureTuple)(sig);
        (_a = this.fields).feePayerSignatures || (_a.feePayerSignatures = []);
        this.fields.feePayerSignatures.push(tuple);
    }
    // Helper for sigRLP and sigFeePayerRLP
    // encode([ encode(inner), outer, 0, 0 ])
    encodeNestedRLP(innerFieldNames, outerFieldNames) {
        const inner = this.getFields(innerFieldNames);
        const outer = this.getFields(outerFieldNames);
        return util_1.RLP.encode([
            util_1.RLP.encode(inner),
            ...outer,
            "0x",
            "0x",
        ]);
    }
    // Helper for senderTxHashRLP and txHashRLP
    // type + encode(fields)
    encodeTypePrefixedRLP(namesWithoutType) {
        const fields = this.getFields(namesWithoutType);
        return util_1.HexStr.concat(this.getField("type"), util_1.RLP.encode(fields));
    }
    // Helper for setFieldsFromRLP
    // Undo encodeTypePrefixedRLP and overwrite this.fields
    decodeTypePrefixedRLP(rlp, namesWithoutType) {
        const type = util_1.HexStr.toNumber(rlp.substring(0, 4));
        if (type !== this.type) {
            this.throwTypeError(`Invalid type '${type}`);
        }
        const withoutType = "0x" + String(rlp).substring(4); // Strip type byte
        const names = ["type", ...namesWithoutType];
        const fields = [this.type, ...util_1.RLP.decode(withoutType)];
        this.setFieldsFromArray(names, fields);
    }
    // Helper for setFieldsFromRLP
    // Given multiple candidates for names[], use the one that matches the RLP decoded array length.
    decodeTypePrefixedVarlenRLP(rlp, ...namesCandidates) {
        // Decode the RLP without the type prefix
        const arrayLen = util_1.RLP.decode("0x" + rlp.substring(4)).length;
        // Find the 'names' list with matching length
        for (let i = 0; i < namesCandidates.length; i++) {
            const names = namesCandidates[i];
            if (arrayLen == names.length) {
                this.decodeTypePrefixedRLP(rlp, names);
                return;
            }
        }
        this.throwTypeError(`Invalid RLP string '${rlp}'`);
    }
}
exports.KlaytnTx = KlaytnTx;
class _KlaytnTxFactory extends field_1.FieldSetFactory {
    constructor() {
        const requiredFields = ["type", "chainId", "txSignatures"];
        super(requiredFields);
    }
    fromObject(fields) {
        // Alias input -> data for compatiblity
        if (fields.input) {
            fields.data = fields.input;
        }
        // In TxTypeSmartContractDeploy, force 'to' = 0x for compatibility
        if (util_1.HexStr.fromNumber(fields.type) == util_1.HexStr.fromNumber(util_1.TxType.SmartContractDeploy) ||
            util_1.HexStr.fromNumber(fields.type) == util_1.HexStr.fromNumber(util_1.TxType.FeeDelegatedSmartContractDeploy) ||
            util_1.HexStr.fromNumber(fields.type) == util_1.HexStr.fromNumber(util_1.TxType.FeeDelegatedSmartContractDeployWithRatio)) {
            fields.to = "0x";
        }
        return super.fromObject(fields);
    }
    fromRLP(rlp) {
        const type = getTypePrefix(rlp);
        if (!(0, util_1.isKlaytnTxType)(type)) {
            throw new Error("Not a Klaytn raw transaction");
        }
        const ctor = this.lookup(type);
        const instance = new ctor();
        instance.setFieldsFromRLP(rlp);
        return instance;
    }
}
exports.KlaytnTxFactory = new _KlaytnTxFactory();
function parseTransaction(rlp) {
    const type = getTypePrefix(rlp);
    if (!(0, util_1.isKlaytnTxType)(type)) {
        return (0, transactions_1.parse)(rlp);
    }
    else {
        return exports.KlaytnTxFactory.fromRLP(rlp).toObject();
    }
}
exports.parseTransaction = parseTransaction;
//# sourceMappingURL=factory.js.map