"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Wallet = void 0;
const providers_1 = require("@ethersproject/providers");
const wallet_1 = require("@ethersproject/wallet");
const web_1 = require("@ethersproject/web");
const js_ext_core_1 = require("@klaytn/js-ext-core");
const ethers_1 = require("ethers");
const utils_1 = require("ethers/lib/utils");
const lodash_1 = __importDefault(require("lodash"));
const keystore_1 = require("./keystore");
// @ethersproject/abstract-signer/src.ts/index.ts:allowedTransactionKeys
const ethersAllowedTransactionKeys = [
    "accessList", "ccipReadEnabled", "chainId", "customData", "data", "from", "gasLimit", "gasPrice", "maxFeePerGas", "maxPriorityFeePerGas", "nonce", "to", "type", "value",
];
// ethers.js may strip or reject some Klaytn-specific transaction fields.
// To prserve transaction fields around super method calls, use
// saveCustomFields and restoreCustomFields.
function saveCustomFields(tx) {
    // Save fields that are not allowed in ethers.js
    const savedFields = {};
    for (const key in tx) {
        // 'from' may not be corresponded to the public key of the private key in a decoupled account.
        if (ethersAllowedTransactionKeys.indexOf(key) === -1 || key == "from") {
            savedFields[key] = lodash_1.default.get(tx, key);
            lodash_1.default.unset(tx, key);
        }
    }
    // Save txtype that is not supported in ethers.js.
    // and disguise as legacy (type 0) transaction.
    //
    // Why disguise as legacy type?
    // Signer.populateTransaction() will not fill gasPrice
    // unless tx type is explicitly Legacy (type=0) or EIP-2930 (type=1).
    // Klaytn tx types, however, always uses gasPrice.
    if (lodash_1.default.isNumber(tx.type) && js_ext_core_1.KlaytnTxFactory.has(tx.type)) {
        savedFields["type"] = tx.type;
        tx.type = 0;
    }
    return savedFields;
}
function restoreCustomFields(tx, savedFields) {
    for (const key in savedFields) {
        lodash_1.default.set(tx, key, savedFields[key]);
    }
}
async function getTransactionRequest(transactionOrRLP) {
    if (lodash_1.default.isString(transactionOrRLP)) {
        return (0, js_ext_core_1.parseTransaction)(transactionOrRLP);
    }
    else {
        const tx = transactionOrRLP;
        return (0, utils_1.resolveProperties)(tx);
    }
}
class Wallet extends wallet_1.Wallet {
    // Override Wallet factories accepting keystores to support KIP-3 (v4) format
    static async fromEncryptedJson(json, password, progress) {
        const { address, privateKey } = await (0, keystore_1.decryptKeystoreList)(json, password, progress);
        return new Wallet(address, privateKey);
    }
    static fromEncryptedJsonSync(json, password) {
        const { address, privateKey } = (0, keystore_1.decryptKeystoreListSync)(json, password);
        return new Wallet(address, privateKey);
    }
    // New Wallet[] factories accepting keystores supporting KIP-3 (v4) format
    static async fromEncryptedJsonList(json, password, progress) {
        const { address, privateKeyList } = await (0, keystore_1.decryptKeystoreList)(json, password, progress);
        return lodash_1.default.map(privateKeyList, (privateKey) => new Wallet(address, privateKey));
    }
    static fromEncryptedJsonListSync(json, password) {
        const { address, privateKeyList } = (0, keystore_1.decryptKeystoreListSync)(json, password);
        return lodash_1.default.map(privateKeyList, (privateKey) => new Wallet(address, privateKey));
    }
    // new KlaytnWallet(privateKey, provider?) or
    // new KlaytnWallet(address, privateKey, provider?)
    constructor(addressOrPrivateKey, privateKeyOrProvider, provider) {
        // First argument is an address.
        if (js_ext_core_1.HexStr.isHex(addressOrPrivateKey, 20)) {
            const address = js_ext_core_1.HexStr.from(addressOrPrivateKey);
            const privateKey = privateKeyOrProvider;
            super(privateKey, provider);
            this.klaytnAddr = address;
        }
        else { // First argument is a private key.
            const privateKey = addressOrPrivateKey;
            const _provider = privateKeyOrProvider;
            super(privateKey, _provider);
        }
    }
    getAddress(legacy) {
        if (legacy || !this.klaytnAddr) {
            return Promise.resolve((0, utils_1.computeAddress)(this.publicKey));
        }
        else {
            return Promise.resolve(this.klaytnAddr);
        }
    }
    // @deprecated in favor of getAddress(true)
    getEtherAddress() {
        return super.getAddress();
    }
    async isDecoupled() {
        if (!this.klaytnAddr) {
            return false;
        }
        else {
            return (await this.getAddress(false)) == (await this.getAddress(true));
        }
    }
    // Fill legacy address for Ethereum TxTypes, and (possibly) decoupled address for Klaytn TxTypes.
    checkTransaction(transaction) {
        const tx = lodash_1.default.clone(transaction);
        const legacy = !js_ext_core_1.KlaytnTxFactory.has(tx.type);
        const expectedFrom = this.getAddress(legacy);
        if (!tx.from) {
            tx.from = expectedFrom;
        }
        else {
            tx.from = Promise.all([
                Promise.resolve(tx.from),
                expectedFrom,
            ]).then(([from, expectedFrom]) => {
                if ((from === null || from === void 0 ? void 0 : from.toLowerCase()) != (expectedFrom === null || expectedFrom === void 0 ? void 0 : expectedFrom.toLowerCase())) {
                    throw new Error(`from address mismatch tx=${JSON.stringify(transaction)} addr=${expectedFrom}`);
                }
                return from;
            });
        }
        return tx;
    }
    async populateTransaction(transaction) {
        const tx = await getTransactionRequest(transaction);
        // Not a Klaytn TxType; fallback to ethers.Wallet
        if (!js_ext_core_1.KlaytnTxFactory.has(tx.type)) {
            return super.populateTransaction(tx);
        }
        // Fill 'from' field.
        if (!tx.from) {
            tx.from = await this.getAddress();
        }
        // If the account address is decoupled from private key,
        // the ethers.Wallet.populateTransaction() may fill the nonce of the wrong address.
        if (!tx.nonce) {
            tx.nonce = await this.provider.getTransactionCount(tx.from);
        }
        // Sometimes estimateGas underestimates the required gas limit.
        // Therefore adding some buffer to the RPC result.
        // Other cases:
        // - ethers.js uses estimateGas result as-is.
        // - Metamask multiplies by 1 or 1.5 depending on chainId
        //   (https://github.com/MetaMask/metamask-extension/blob/v11.3.0/ui/ducks/send/helpers.js#L126)
        // TODO: To minimize buffer, add constant intrinsic gas overhead instead of multiplier.
        if (!tx.gasLimit) {
            const bufferMultiplier = 2.5;
            const gasLimit = await this.provider.estimateGas(tx);
            tx.gasLimit = Math.ceil(gasLimit.toNumber() * bufferMultiplier);
        }
        // Leave rest of the fields to ethers
        const savedFields = saveCustomFields(tx);
        const populatedTx = await super.populateTransaction(tx);
        restoreCustomFields(populatedTx, savedFields);
        return populatedTx;
    }
    // @deprecated in favor of parseTransaction
    decodeTxFromRLP(rlp) {
        return (0, js_ext_core_1.parseTransaction)(rlp);
    }
    // Sign as a sender
    // tx.sigs += Sign(tx.sigRLP(), wallet.privateKey)
    // return tx.txHashRLP() or tx.senderTxHashRLP();
    async signTransaction(transaction) {
        var _a;
        const tx = await getTransactionRequest(transaction);
        // Not a Klaytn TxType; fallback to ethers.Wallet
        if (!js_ext_core_1.KlaytnTxFactory.has(tx.type)) {
            return super.signTransaction(tx);
        }
        // Because RLP-encoded tx may not contain chainId, fill up here.
        (_a = tx.chainId) !== null && _a !== void 0 ? _a : (tx.chainId = await this._chainIdFromTx(tx));
        const klaytnTx = js_ext_core_1.KlaytnTxFactory.fromObject(tx);
        const sigHash = (0, utils_1.keccak256)(klaytnTx.sigRLP());
        const sig = this._eip155sign(sigHash, tx.chainId);
        klaytnTx.addSenderSig(sig);
        if ((0, js_ext_core_1.isFeePayerSigTxType)(klaytnTx.type)) {
            return klaytnTx.senderTxHashRLP();
        }
        else {
            return klaytnTx.txHashRLP();
        }
    }
    // Sign as a fee payer
    // tx.feepayerSigs += Sign(tx.sigFeePayerRLP(), wallet.privateKey)
    // return tx.txHashRLP();
    async signTransactionAsFeePayer(transaction) {
        var _a, _b;
        const tx = await getTransactionRequest(transaction);
        // Not a Klaytn TxType; not supported
        if (!js_ext_core_1.KlaytnTxFactory.has(tx.type)) {
            throw new Error(`feePayer signature not supported for tx type ${tx.type}`);
        }
        // Because RLP-encoded tx may not contain chainId, fill up here.
        (_a = tx.chainId) !== null && _a !== void 0 ? _a : (tx.chainId = await this._chainIdFromTx(tx));
        // Automatically populate 'feePayer' field, just like how 'from' field is populated.
        // @ts-ignore: feePayer field does not exist in ethers.TransactionRequest type
        (_b = tx.feePayer) !== null && _b !== void 0 ? _b : (tx.feePayer = await this.getAddress());
        const klaytnTx = js_ext_core_1.KlaytnTxFactory.fromObject(tx);
        if (!(0, js_ext_core_1.isFeePayerSigTxType)(klaytnTx.type)) {
            klaytnTx.throwTypeError("feePayer signature not supported");
        }
        const sigFeePayerHash = (0, utils_1.keccak256)(klaytnTx.sigFeePayerRLP());
        const sig = this._eip155sign(sigFeePayerHash, tx.chainId);
        klaytnTx.addFeePayerSig(sig);
        return klaytnTx.txHashRLP();
    }
    async sendTransaction(transaction) {
        this._checkProvider("sendTransaction");
        const populatedTx = await this.populateTransaction(transaction);
        const signedTx = await this.signTransaction(populatedTx);
        if (!js_ext_core_1.KlaytnTxFactory.has(populatedTx.type)) {
            return await this.provider.sendTransaction(signedTx);
        }
        else {
            return await this._sendRawTransaction(signedTx);
        }
    }
    async sendTransactionAsFeePayer(transaction) {
        this._checkProvider("sendTransactionAsFeePayer");
        const populatedTx = await this.populateTransaction(transaction);
        const signedTx = await this.signTransactionAsFeePayer(populatedTx);
        return await this._sendRawTransaction(signedTx);
    }
    _eip155sign(digest, chainId) {
        const sig = this._signingKey().signDigest(digest);
        if (chainId) {
            sig.v = sig.recoveryParam + chainId * 2 + 35;
        }
        return sig;
    }
    // Extract chainId from tx signatures.
    // If no signatures, query provider.
    async _chainIdFromTx(tx) {
        var _a, _b;
        function extractFromSig(field) {
            if (lodash_1.default.isArray(field) && field.length > 0 &&
                lodash_1.default.isArray(field[0]) && field[0].length == 3) {
                const v = ethers_1.BigNumber.from(field[0][0]).toNumber();
                return (v - 35) / 2;
            }
            return undefined;
        }
        return ((_b = (_a = extractFromSig(tx.txSignatures)) !== null && _a !== void 0 ? _a : extractFromSig(tx.feePayerSignatures)) !== null && _b !== void 0 ? _b : this.getChainId());
    }
    async _sendRawTransaction(signedTx) {
        if (!(this.provider instanceof providers_1.JsonRpcProvider)) {
            throw new Error("Klaytn typed transaction can only be broadcasted to a Klaytn JSON-RPC server");
        }
        else {
            const txhash = await this.provider.send("klay_sendRawTransaction", [signedTx]);
            // Retry until the transaction shows up in the txpool
            // Using poll() like in the ethers.JsonRpcProvider.sendTransaction
            // https://github.com/ethers-io/ethers.js/blob/v5.7/packages/providers/src.ts/json-rpc-provider.ts#L283
            const pollFunc = async () => {
                const tx = await this.provider.getTransaction(txhash);
                if (tx == null) {
                    return undefined; // retry
                }
                else {
                    return tx; // success
                }
            };
            return (0, web_1.poll)(pollFunc);
        }
    }
}
exports.Wallet = Wallet;
//# sourceMappingURL=signer.js.map