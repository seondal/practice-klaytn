"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _ApiClient = _interopRequireDefault(require("../ApiClient"));
var _AddPeer200Response = _interopRequireDefault(require("../model/AddPeer200Response"));
var _AddPeerRequest = _interopRequireDefault(require("../model/AddPeerRequest"));
var _Datadir200Response = _interopRequireDefault(require("../model/Datadir200Response"));
var _DatadirRequest = _interopRequireDefault(require("../model/DatadirRequest"));
var _ExportChain200Response = _interopRequireDefault(require("../model/ExportChain200Response"));
var _ExportChainRequest = _interopRequireDefault(require("../model/ExportChainRequest"));
var _GetSpamThrottlerCandidateList200Response = _interopRequireDefault(require("../model/GetSpamThrottlerCandidateList200Response"));
var _GetSpamThrottlerCandidateListRequest = _interopRequireDefault(require("../model/GetSpamThrottlerCandidateListRequest"));
var _GetSpamThrottlerThrottleList200Response = _interopRequireDefault(require("../model/GetSpamThrottlerThrottleList200Response"));
var _GetSpamThrottlerThrottleListRequest = _interopRequireDefault(require("../model/GetSpamThrottlerThrottleListRequest"));
var _GetSpamThrottlerWhiteList200Response = _interopRequireDefault(require("../model/GetSpamThrottlerWhiteList200Response"));
var _GetSpamThrottlerWhiteListRequest = _interopRequireDefault(require("../model/GetSpamThrottlerWhiteListRequest"));
var _ImportChain200Response = _interopRequireDefault(require("../model/ImportChain200Response"));
var _ImportChainFromString200Response = _interopRequireDefault(require("../model/ImportChainFromString200Response"));
var _ImportChainFromStringRequest = _interopRequireDefault(require("../model/ImportChainFromStringRequest"));
var _ImportChainRequest = _interopRequireDefault(require("../model/ImportChainRequest"));
var _NodeInfo200Response = _interopRequireDefault(require("../model/NodeInfo200Response"));
var _NodeInfoRequest = _interopRequireDefault(require("../model/NodeInfoRequest"));
var _Peers200Response = _interopRequireDefault(require("../model/Peers200Response"));
var _PeersRequest = _interopRequireDefault(require("../model/PeersRequest"));
var _RemovePeer200Response = _interopRequireDefault(require("../model/RemovePeer200Response"));
var _RemovePeerRequest = _interopRequireDefault(require("../model/RemovePeerRequest"));
var _SaveTrieNodeCacheToDisk200Response = _interopRequireDefault(require("../model/SaveTrieNodeCacheToDisk200Response"));
var _SaveTrieNodeCacheToDiskRequest = _interopRequireDefault(require("../model/SaveTrieNodeCacheToDiskRequest"));
var _SetMaxSubscriptionPerWSConn200Response = _interopRequireDefault(require("../model/SetMaxSubscriptionPerWSConn200Response"));
var _SetMaxSubscriptionPerWSConnRequest = _interopRequireDefault(require("../model/SetMaxSubscriptionPerWSConnRequest"));
var _SetSpamThrottlerWhiteList200Response = _interopRequireDefault(require("../model/SetSpamThrottlerWhiteList200Response"));
var _SetSpamThrottlerWhiteListRequest = _interopRequireDefault(require("../model/SetSpamThrottlerWhiteListRequest"));
var _SpamThrottlerConfig200Response = _interopRequireDefault(require("../model/SpamThrottlerConfig200Response"));
var _SpamThrottlerConfigRequest = _interopRequireDefault(require("../model/SpamThrottlerConfigRequest"));
var _StartHTTP200Response = _interopRequireDefault(require("../model/StartHTTP200Response"));
var _StartHTTPRequest = _interopRequireDefault(require("../model/StartHTTPRequest"));
var _StartSpamThrottler200Response = _interopRequireDefault(require("../model/StartSpamThrottler200Response"));
var _StartSpamThrottlerRequest = _interopRequireDefault(require("../model/StartSpamThrottlerRequest"));
var _StartStateMigration200Response = _interopRequireDefault(require("../model/StartStateMigration200Response"));
var _StartStateMigrationRequest = _interopRequireDefault(require("../model/StartStateMigrationRequest"));
var _StartWS200Response = _interopRequireDefault(require("../model/StartWS200Response"));
var _StartWSRequest = _interopRequireDefault(require("../model/StartWSRequest"));
var _StateMigrationStatus200Response = _interopRequireDefault(require("../model/StateMigrationStatus200Response"));
var _StateMigrationStatusRequest = _interopRequireDefault(require("../model/StateMigrationStatusRequest"));
var _StopHTTP200Response = _interopRequireDefault(require("../model/StopHTTP200Response"));
var _StopHTTPRequest = _interopRequireDefault(require("../model/StopHTTPRequest"));
var _StopSpamThrottler200Response = _interopRequireDefault(require("../model/StopSpamThrottler200Response"));
var _StopSpamThrottlerRequest = _interopRequireDefault(require("../model/StopSpamThrottlerRequest"));
var _StopStateMigration200Response = _interopRequireDefault(require("../model/StopStateMigration200Response"));
var _StopStateMigrationRequest = _interopRequireDefault(require("../model/StopStateMigrationRequest"));
var _StopWS200Response = _interopRequireDefault(require("../model/StopWS200Response"));
var _StopWSRequest = _interopRequireDefault(require("../model/StopWSRequest"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); } /**
 * web3rpc
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.9.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */
/**
* Admin service.
* @module api/AdminApi
* @version 0.9.8
*/
var AdminApi = exports["default"] = /*#__PURE__*/function () {
  /**
  * Constructs a new AdminApi. 
  * @alias module:api/AdminApi
  * @class
  * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
  * default to {@link module:ApiClient#instance} if unspecified.
  */
  function AdminApi(apiClient) {
    _classCallCheck(this, AdminApi);
    this.apiClient = apiClient || _ApiClient["default"].instance;
  }

  /**
   * Callback function to receive the result of the addPeer operation.
   * @callback module:api/AdminApi~addPeerCallback
   * @param {String} error Error message, if any.
   * @param {module:model/AddPeer200Response} data The data returned by the service call.
   * @param {String} response The complete HTTP response.
   */

  /**
   * [addPeer]
   * The addPeer is an administrative method that requests adding a new remote node to the list of tracked static nodes. The node will try to maintain connectivity to these nodes at all times, reconnecting every once in a while if the remote connection goes down.  The method accepts a single argument kni, which means \"Klaytn Network Identifier\". It is similar to the enode concept in the geth. It is URL of the remote peer to start tracking and returns a BOOL indicating whether the peer was accepted for tracking or some error occurred.  **JSONRPC:** `admin_addPeer` 
   * @param {String} url Peer's kni URL.
   * @param {Object} opts Optional parameters
   * @param {module:model/AddPeerRequest} opts.addPeerRequest 
   * @param {module:api/AdminApi~addPeerCallback} callback The callback function, accepting three arguments: error, data, response
   * data is of type: {@link module:model/AddPeer200Response}
   */
  _createClass(AdminApi, [{
    key: "addPeer",
    value: function addPeer(url, opts, callback) {
      opts = opts || {};
      // verify the required parameter 'url' is set
      if (url === undefined || url === null) {
        throw new Error("Missing the required parameter 'url' when calling addPeer");
      }
      var postBody = new _AddPeerRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      postBody.params.push(url);
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _AddPeer200Response["default"];
      return this.apiClient.callApi('/admin/addPeer', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the datadir operation.
     * @callback module:api/AdminApi~datadirCallback
     * @param {String} error Error message, if any.
     * @param {module:model/Datadir200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [datadir]
     * The datadir administrative property can be queried for the absolute path the running Klaytn node currently uses to store all its databases. The default path is different depending on the node types (kcn, kpn, and ken) and the OS type.  **JSONRPC:** `admin_datadir` 
     * @param {Object} opts Optional parameters
     * @param {module:model/DatadirRequest} opts.datadirRequest 
     * @param {module:api/AdminApi~datadirCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/Datadir200Response}
     */
  }, {
    key: "datadir",
    value: function datadir(opts, callback) {
      opts = opts || {};
      var postBody = new _DatadirRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _Datadir200Response["default"];
      return this.apiClient.callApi('/admin/datadir', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the exportChain operation.
     * @callback module:api/AdminApi~exportChainCallback
     * @param {String} error Error message, if any.
     * @param {module:model/ExportChain200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [exportChain]
     * The exportChain is an administrative method that exports the blockchain to a file.  **JSONRPC:** `admin_exportChain` 
     * @param {String} fileName the fully qualified path to the file where the blockchain must be exported.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.firstBlock First block
     * @param {Number} opts.lastBlock Last block
     * @param {module:model/ExportChainRequest} opts.exportChainRequest 
     * @param {module:api/AdminApi~exportChainCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/ExportChain200Response}
     */
  }, {
    key: "exportChain",
    value: function exportChain(fileName, opts, callback) {
      opts = opts || {};
      // verify the required parameter 'fileName' is set
      if (fileName === undefined || fileName === null) {
        throw new Error("Missing the required parameter 'fileName' when calling exportChain");
      }
      var postBody = new _ExportChainRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      postBody.params.push(fileName);
      var defaultValue = null;
      defaultValue = "latest";
      var optParam = opts['firstBlock'] || opts[optsIndex++] || defaultValue;
      if (optParam === undefined || optParam === null) {
        throw new Error("Missing the required parameter 'firstBlock' when calling exportChain");
      }
      postBody.params.push(optParam);
      var defaultValue = null;
      defaultValue = "latest";
      var optParam = opts['lastBlock'] || opts[optsIndex++] || defaultValue;
      if (optParam === undefined || optParam === null) {
        throw new Error("Missing the required parameter 'lastBlock' when calling exportChain");
      }
      postBody.params.push(optParam);
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _ExportChain200Response["default"];
      return this.apiClient.callApi('/admin/exportChain', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the getSpamThrottlerCandidateList operation.
     * @callback module:api/AdminApi~getSpamThrottlerCandidateListCallback
     * @param {String} error Error message, if any.
     * @param {module:model/GetSpamThrottlerCandidateList200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [getSpamThrottlerCandidateList]
     * Get spam throttler candidate list  **JSONRPC:** `admin_getSpamThrottlerCandidateList` 
     * @param {Object} opts Optional parameters
     * @param {module:model/GetSpamThrottlerCandidateListRequest} opts.getSpamThrottlerCandidateListRequest 
     * @param {module:api/AdminApi~getSpamThrottlerCandidateListCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/GetSpamThrottlerCandidateList200Response}
     */
  }, {
    key: "getSpamThrottlerCandidateList",
    value: function getSpamThrottlerCandidateList(opts, callback) {
      opts = opts || {};
      var postBody = new _GetSpamThrottlerCandidateListRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _GetSpamThrottlerCandidateList200Response["default"];
      return this.apiClient.callApi('/admin/getSpamThrottlerCandidateList', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the getSpamThrottlerThrottleList operation.
     * @callback module:api/AdminApi~getSpamThrottlerThrottleListCallback
     * @param {String} error Error message, if any.
     * @param {module:model/GetSpamThrottlerThrottleList200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [getSpamThrottlerThrottleList]
     * Get spam throttler throttle list  **JSONRPC:** `admin_getSpamThrottlerThrottleList` 
     * @param {Object} opts Optional parameters
     * @param {module:model/GetSpamThrottlerThrottleListRequest} opts.getSpamThrottlerThrottleListRequest 
     * @param {module:api/AdminApi~getSpamThrottlerThrottleListCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/GetSpamThrottlerThrottleList200Response}
     */
  }, {
    key: "getSpamThrottlerThrottleList",
    value: function getSpamThrottlerThrottleList(opts, callback) {
      opts = opts || {};
      var postBody = new _GetSpamThrottlerThrottleListRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _GetSpamThrottlerThrottleList200Response["default"];
      return this.apiClient.callApi('/admin/getSpamThrottlerThrottleList', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the getSpamThrottlerWhiteList operation.
     * @callback module:api/AdminApi~getSpamThrottlerWhiteListCallback
     * @param {String} error Error message, if any.
     * @param {module:model/GetSpamThrottlerWhiteList200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [getSpamThrottlerWhiteList]
     * Get spam throttler white list  **JSONRPC:** `admin_getSpamThrottlerWhiteList` 
     * @param {Object} opts Optional parameters
     * @param {module:model/GetSpamThrottlerWhiteListRequest} opts.getSpamThrottlerWhiteListRequest 
     * @param {module:api/AdminApi~getSpamThrottlerWhiteListCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/GetSpamThrottlerWhiteList200Response}
     */
  }, {
    key: "getSpamThrottlerWhiteList",
    value: function getSpamThrottlerWhiteList(opts, callback) {
      opts = opts || {};
      var postBody = new _GetSpamThrottlerWhiteListRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _GetSpamThrottlerWhiteList200Response["default"];
      return this.apiClient.callApi('/admin/getSpamThrottlerWhiteList', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the importChain operation.
     * @callback module:api/AdminApi~importChainCallback
     * @param {String} error Error message, if any.
     * @param {module:model/ImportChain200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [importChain]
     * The importChain is an administrative method that imports an exported chain from a file into a node. This method imports only blocks that haven't existed in a Klaytn node. This method does not delete any data of the existing chain.  **JSONRPC:** `admin_importChain` 
     * @param {String} fileName the fully qualified path to the file containing the chain to be imported.
     * @param {Object} opts Optional parameters
     * @param {module:model/ImportChainRequest} opts.importChainRequest 
     * @param {module:api/AdminApi~importChainCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/ImportChain200Response}
     */
  }, {
    key: "importChain",
    value: function importChain(fileName, opts, callback) {
      opts = opts || {};
      // verify the required parameter 'fileName' is set
      if (fileName === undefined || fileName === null) {
        throw new Error("Missing the required parameter 'fileName' when calling importChain");
      }
      var postBody = new _ImportChainRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      postBody.params.push(fileName);
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _ImportChain200Response["default"];
      return this.apiClient.callApi('/admin/importChain', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the importChainFromString operation.
     * @callback module:api/AdminApi~importChainFromStringCallback
     * @param {String} error Error message, if any.
     * @param {module:model/ImportChainFromString200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [importChainFromString]
     * The importChainFromString is an administrative method that imports a chain from a RLP-encoded string of blocks into a Klaytn node. This only works if there is no existing chain in a Klaytn node. This method does not delete any data of the existing chain.         **JSONRPC:** `admin_importChainFromString` 
     * @param {String} blockRlp the RLP-encoded string that represents the blocks to be imported. (equals to the return value of debug.getBlockRlp)
     * @param {Object} opts Optional parameters
     * @param {module:model/ImportChainFromStringRequest} opts.importChainFromStringRequest 
     * @param {module:api/AdminApi~importChainFromStringCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/ImportChainFromString200Response}
     */
  }, {
    key: "importChainFromString",
    value: function importChainFromString(blockRlp, opts, callback) {
      opts = opts || {};
      // verify the required parameter 'blockRlp' is set
      if (blockRlp === undefined || blockRlp === null) {
        throw new Error("Missing the required parameter 'blockRlp' when calling importChainFromString");
      }
      var postBody = new _ImportChainFromStringRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      postBody.params.push(blockRlp);
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _ImportChainFromString200Response["default"];
      return this.apiClient.callApi('/admin/importChainFromString', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the nodeInfo operation.
     * @callback module:api/AdminApi~nodeInfoCallback
     * @param {String} error Error message, if any.
     * @param {module:model/NodeInfo200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [nodeInfo]
     * The nodeInfo administrative property can be queried for all the information known about the running Klaytn node at the networking granularity. These include general information about the node itself as a participant of the devp2p P2P overlay protocol, as well as specialized information added by each of the running application protocols, e.g., klay.  **JSONRPC:** `admin_nodeInfo` 
     * @param {Object} opts Optional parameters
     * @param {module:model/NodeInfoRequest} opts.nodeInfoRequest 
     * @param {module:api/AdminApi~nodeInfoCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/NodeInfo200Response}
     */
  }, {
    key: "nodeInfo",
    value: function nodeInfo(opts, callback) {
      opts = opts || {};
      var postBody = new _NodeInfoRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _NodeInfo200Response["default"];
      return this.apiClient.callApi('/admin/nodeInfo', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the peers operation.
     * @callback module:api/AdminApi~peersCallback
     * @param {String} error Error message, if any.
     * @param {module:model/Peers200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [peers]
     * The peers administrative property can be queried for all the information known about the connected remote nodes at the networking granularity. These include general information about the nodes themselves as participants of the devp2p P2P overlay protocol, as well as specialized information added by each of the running application protocols.          **JSONRPC:** `admin_peers` 
     * @param {Object} opts Optional parameters
     * @param {module:model/PeersRequest} opts.peersRequest 
     * @param {module:api/AdminApi~peersCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/Peers200Response}
     */
  }, {
    key: "peers",
    value: function peers(opts, callback) {
      opts = opts || {};
      var postBody = new _PeersRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _Peers200Response["default"];
      return this.apiClient.callApi('/admin/peers', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the removePeer operation.
     * @callback module:api/AdminApi~removePeerCallback
     * @param {String} error Error message, if any.
     * @param {module:model/RemovePeer200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [removePeer]
     * The removePeer is an administrative method that requests removing a node from the list of tracked static nodes.  The method accepts a single argument kni, which means \"Klaytn Network Identifier\". It is similar to the enode concept in the geth. It is URL of the remote peer to be removed from a list and returns a BOOL indicating whether the peer was removed or some error occurred.          **JSONRPC:** `admin_removePeer` 
     * @param {String} url Peer's kni URL.
     * @param {Object} opts Optional parameters
     * @param {module:model/RemovePeerRequest} opts.removePeerRequest 
     * @param {module:api/AdminApi~removePeerCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/RemovePeer200Response}
     */
  }, {
    key: "removePeer",
    value: function removePeer(url, opts, callback) {
      opts = opts || {};
      // verify the required parameter 'url' is set
      if (url === undefined || url === null) {
        throw new Error("Missing the required parameter 'url' when calling removePeer");
      }
      var postBody = new _RemovePeerRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      postBody.params.push(url);
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _RemovePeer200Response["default"];
      return this.apiClient.callApi('/admin/removePeer', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the saveTrieNodeCacheToDisk operation.
     * @callback module:api/AdminApi~saveTrieNodeCacheToDiskCallback
     * @param {String} error Error message, if any.
     * @param {module:model/SaveTrieNodeCacheToDisk200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [saveTrieNodeCacheToDisk]
     * The saveTrieNodeCacheToDisk is an administrative method that starts saving the cached trie node to the disk to reuse them when the node restarts. Cached trie node data will be stored to and loaded from $DATA_DIR/fastcache . This method returns an error if the saving process has been already triggered or trie node cache is disabled. This feature is supported since Klaytn 1.5.3.         **JSONRPC:** `admin_saveTrieNodeCacheToDisk` 
     * @param {Object} opts Optional parameters
     * @param {module:model/SaveTrieNodeCacheToDiskRequest} opts.saveTrieNodeCacheToDiskRequest 
     * @param {module:api/AdminApi~saveTrieNodeCacheToDiskCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/SaveTrieNodeCacheToDisk200Response}
     */
  }, {
    key: "saveTrieNodeCacheToDisk",
    value: function saveTrieNodeCacheToDisk(opts, callback) {
      opts = opts || {};
      var postBody = new _SaveTrieNodeCacheToDiskRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _SaveTrieNodeCacheToDisk200Response["default"];
      return this.apiClient.callApi('/admin/saveTrieNodeCacheToDisk', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the setMaxSubscriptionPerWSConn operation.
     * @callback module:api/AdminApi~setMaxSubscriptionPerWSConnCallback
     * @param {String} error Error message, if any.
     * @param {module:model/SetMaxSubscriptionPerWSConn200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [setMaxSubscriptionPerWSConn]
     * The setMaxSubscriptionPerWSConn is an administrative method that sets the maximum allowed number of subscriptions per single WebSocket connection. For example, if the maximum number is set to five and a user requests more than five subscriptions through the klay_subscribe API, an error message \"Maximum 5 subscriptions are allowed for a WebSocket connection\" will be displayed. This feature is supported since Klaytn 1.6.0.  **JSONRPC:** `admin_setMaxSubscriptionPerWSConn` 
     * @param {Number} limit The maximum allowed number of subscriptions per single WebSocket connection.
     * @param {Object} opts Optional parameters
     * @param {module:model/SetMaxSubscriptionPerWSConnRequest} opts.setMaxSubscriptionPerWSConnRequest 
     * @param {module:api/AdminApi~setMaxSubscriptionPerWSConnCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/SetMaxSubscriptionPerWSConn200Response}
     */
  }, {
    key: "setMaxSubscriptionPerWSConn",
    value: function setMaxSubscriptionPerWSConn(limit, opts, callback) {
      opts = opts || {};
      // verify the required parameter 'limit' is set
      if (limit === undefined || limit === null) {
        throw new Error("Missing the required parameter 'limit' when calling setMaxSubscriptionPerWSConn");
      }
      var postBody = new _SetMaxSubscriptionPerWSConnRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      postBody.params.push(limit);
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _SetMaxSubscriptionPerWSConn200Response["default"];
      return this.apiClient.callApi('/admin/setMaxSubscriptionPerWSConn', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the setSpamThrottlerWhiteList operation.
     * @callback module:api/AdminApi~setSpamThrottlerWhiteListCallback
     * @param {String} error Error message, if any.
     * @param {module:model/SetSpamThrottlerWhiteList200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [setSpamThrottlerWhiteList]
     * Set spam throttler white list  **JSONRPC:** `admin_setSpamThrottlerWhiteList` 
     * @param {Array.<String>} addresses 
     * @param {Object} opts Optional parameters
     * @param {module:model/SetSpamThrottlerWhiteListRequest} opts.setSpamThrottlerWhiteListRequest 
     * @param {module:api/AdminApi~setSpamThrottlerWhiteListCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/SetSpamThrottlerWhiteList200Response}
     */
  }, {
    key: "setSpamThrottlerWhiteList",
    value: function setSpamThrottlerWhiteList(addresses, opts, callback) {
      opts = opts || {};
      // verify the required parameter 'addresses' is set
      if (addresses === undefined || addresses === null) {
        throw new Error("Missing the required parameter 'addresses' when calling setSpamThrottlerWhiteList");
      }
      var postBody = new _SetSpamThrottlerWhiteListRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      postBody.params.push(addresses);
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _SetSpamThrottlerWhiteList200Response["default"];
      return this.apiClient.callApi('/admin/setSpamThrottlerWhiteList', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the spamThrottlerConfig operation.
     * @callback module:api/AdminApi~spamThrottlerConfigCallback
     * @param {String} error Error message, if any.
     * @param {module:model/SpamThrottlerConfig200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [spamThrottlerConfig]
     * Get spam throttler config  **JSONRPC:** `admin_spamThrottlerConfig` 
     * @param {Object} opts Optional parameters
     * @param {module:model/SpamThrottlerConfigRequest} opts.spamThrottlerConfigRequest 
     * @param {module:api/AdminApi~spamThrottlerConfigCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/SpamThrottlerConfig200Response}
     */
  }, {
    key: "spamThrottlerConfig",
    value: function spamThrottlerConfig(opts, callback) {
      opts = opts || {};
      var postBody = new _SpamThrottlerConfigRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _SpamThrottlerConfig200Response["default"];
      return this.apiClient.callApi('/admin/spamThrottlerConfig', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the startHTTP operation.
     * @callback module:api/AdminApi~startHTTPCallback
     * @param {String} error Error message, if any.
     * @param {module:model/StartHTTP200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [startHTTP]
     * The startHTTP is an administrative method that starts an HTTP based JSON RPC API webserver to handle client requests.  The method returns a boolean flag specifying whether the HTTP RPC listener was opened or not. Please note, only one HTTP endpoint is allowed to be active at any time.  **NOTE:** *This API replaces admin_startRPC. The admin_startRPC will be deprecated soon.*  **JSONRPC:** `admin_startHTTP` 
     * @param {Object} opts Optional parameters
     * @param {String} opts.host (optional) network interface to open the listener socket on (default \"localhost\").
     * @param {Number} opts.port (optional) network port to open the listener socket on (default 8551).
     * @param {String} opts.cors (optional) cross-origin resource sharing header to use (default \"\").
     * @param {String} opts.apis (optional) API modules to offer over this interface (default \"klay,net,rpc\").
     * @param {module:model/StartHTTPRequest} opts.startHTTPRequest 
     * @param {module:api/AdminApi~startHTTPCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/StartHTTP200Response}
     */
  }, {
    key: "startHTTP",
    value: function startHTTP(opts, callback) {
      opts = opts || {};
      var postBody = new _StartHTTPRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      var defaultValue = null;
      var optParam = opts['host'] || opts[optsIndex++] || defaultValue;
      if (optParam === undefined || optParam === null) {
        throw new Error("Missing the required parameter 'host' when calling startHTTP");
      }
      postBody.params.push(optParam);
      var defaultValue = null;
      var optParam = opts['port'] || opts[optsIndex++] || defaultValue;
      if (optParam === undefined || optParam === null) {
        throw new Error("Missing the required parameter 'port' when calling startHTTP");
      }
      postBody.params.push(optParam);
      var defaultValue = null;
      var optParam = opts['cors'] || opts[optsIndex++] || defaultValue;
      if (optParam === undefined || optParam === null) {
        throw new Error("Missing the required parameter 'cors' when calling startHTTP");
      }
      postBody.params.push(optParam);
      var defaultValue = null;
      var optParam = opts['apis'] || opts[optsIndex++] || defaultValue;
      if (optParam === undefined || optParam === null) {
        throw new Error("Missing the required parameter 'apis' when calling startHTTP");
      }
      postBody.params.push(optParam);
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _StartHTTP200Response["default"];
      return this.apiClient.callApi('/admin/startHTTP', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the startSpamThrottler operation.
     * @callback module:api/AdminApi~startSpamThrottlerCallback
     * @param {String} error Error message, if any.
     * @param {module:model/StartSpamThrottler200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [startSpamThrottler]
     * Start spam throttler  **JSONRPC:** `admin_startSpamThrottler` 
     * @param {Object} opts Optional parameters
     * @param {module:model/StartSpamThrottlerRequest} opts.startSpamThrottlerRequest 
     * @param {module:api/AdminApi~startSpamThrottlerCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/StartSpamThrottler200Response}
     */
  }, {
    key: "startSpamThrottler",
    value: function startSpamThrottler(opts, callback) {
      opts = opts || {};
      var postBody = new _StartSpamThrottlerRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _StartSpamThrottler200Response["default"];
      return this.apiClient.callApi('/admin/startSpamThrottler', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the startStateMigration operation.
     * @callback module:api/AdminApi~startStateMigrationCallback
     * @param {String} error Error message, if any.
     * @param {module:model/StartStateMigration200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [startStateMigration]
     * The startStateMigration is an administrative method that starts a state migration and removes old state/storage trie nodes. This can save the storage space of a Klaytn node. The method returns an error if it fails to start a state migration, or null if it succeeds to start. NOTE: After the state migration, the node cannot serve APIs with previous states.  **JSONRPC:** `admin_startStateMigration` 
     * @param {Object} opts Optional parameters
     * @param {module:model/StartStateMigrationRequest} opts.startStateMigrationRequest 
     * @param {module:api/AdminApi~startStateMigrationCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/StartStateMigration200Response}
     */
  }, {
    key: "startStateMigration",
    value: function startStateMigration(opts, callback) {
      opts = opts || {};
      var postBody = new _StartStateMigrationRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _StartStateMigration200Response["default"];
      return this.apiClient.callApi('/admin/startStateMigration', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the startWS operation.
     * @callback module:api/AdminApi~startWSCallback
     * @param {String} error Error message, if any.
     * @param {module:model/StartWS200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [startWS]
     * The startWS is an administrative method that starts an WebSocket based JSON RPC API webserver to handle client requests.  The method returns a boolean flag specifying whether the WebSocket RPC listener was opened or not. Please note, only one WebSocket endpoint is allowed to be active at any time.       **JSONRPC:** `admin_startWS` 
     * @param {Object} opts Optional parameters
     * @param {String} opts.host (optional) network interface to open the listener socket on (default \"localhost\").
     * @param {Number} opts.port (optional) network port to open the listener socket on (default 8551).
     * @param {String} opts.cors (optional) cross-origin resource sharing header to use (default \"\").
     * @param {String} opts.apis (optional) API modules to offer over this interface (default \"klay,net,rpc\").
     * @param {module:model/StartWSRequest} opts.startWSRequest 
     * @param {module:api/AdminApi~startWSCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/StartWS200Response}
     */
  }, {
    key: "startWS",
    value: function startWS(opts, callback) {
      opts = opts || {};
      var postBody = new _StartWSRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      var defaultValue = null;
      var optParam = opts['host'] || opts[optsIndex++] || defaultValue;
      if (optParam === undefined || optParam === null) {
        throw new Error("Missing the required parameter 'host' when calling startWS");
      }
      postBody.params.push(optParam);
      var defaultValue = null;
      var optParam = opts['port'] || opts[optsIndex++] || defaultValue;
      if (optParam === undefined || optParam === null) {
        throw new Error("Missing the required parameter 'port' when calling startWS");
      }
      postBody.params.push(optParam);
      var defaultValue = null;
      var optParam = opts['cors'] || opts[optsIndex++] || defaultValue;
      if (optParam === undefined || optParam === null) {
        throw new Error("Missing the required parameter 'cors' when calling startWS");
      }
      postBody.params.push(optParam);
      var defaultValue = null;
      var optParam = opts['apis'] || opts[optsIndex++] || defaultValue;
      if (optParam === undefined || optParam === null) {
        throw new Error("Missing the required parameter 'apis' when calling startWS");
      }
      postBody.params.push(optParam);
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _StartWS200Response["default"];
      return this.apiClient.callApi('/admin/startWS', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the stateMigrationStatus operation.
     * @callback module:api/AdminApi~stateMigrationStatusCallback
     * @param {String} error Error message, if any.
     * @param {module:model/StateMigrationStatus200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [stateMigrationStatus]
     * The stateMigrationStatus is an administrative method that returns the status information of the state migration. This method takes no parameters and returns the status of the currently running state migration.  **JSONRPC:** `admin_stateMigrationStatus` 
     * @param {Object} opts Optional parameters
     * @param {module:model/StateMigrationStatusRequest} opts.stateMigrationStatusRequest 
     * @param {module:api/AdminApi~stateMigrationStatusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/StateMigrationStatus200Response}
     */
  }, {
    key: "stateMigrationStatus",
    value: function stateMigrationStatus(opts, callback) {
      opts = opts || {};
      var postBody = new _StateMigrationStatusRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _StateMigrationStatus200Response["default"];
      return this.apiClient.callApi('/admin/stateMigrationStatus', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the stopHTTP operation.
     * @callback module:api/AdminApi~stopHTTPCallback
     * @param {String} error Error message, if any.
     * @param {module:model/StopHTTP200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [stopHTTP]
     * The stopHTTP is an administrative method that closes the currently open HTTP RPC endpoint. As the node can only have a single HTTP endpoint running, this method takes no parameters, returning a boolean whether the endpoint was closed or not.  **NOTE:** This API replaces admin_stopRPC. The admin_stopRPC will be deprecated soon.  **JSONRPC:** `admin_stopHTTP` 
     * @param {Object} opts Optional parameters
     * @param {module:model/StopHTTPRequest} opts.stopHTTPRequest 
     * @param {module:api/AdminApi~stopHTTPCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/StopHTTP200Response}
     */
  }, {
    key: "stopHTTP",
    value: function stopHTTP(opts, callback) {
      opts = opts || {};
      var postBody = new _StopHTTPRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _StopHTTP200Response["default"];
      return this.apiClient.callApi('/admin/stopHTTP', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the stopSpamThrottler operation.
     * @callback module:api/AdminApi~stopSpamThrottlerCallback
     * @param {String} error Error message, if any.
     * @param {module:model/StopSpamThrottler200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [stopSpamThrottler]
     * Stop spam throttler  **JSONRPC:** `admin_stopSpamThrottler` 
     * @param {Object} opts Optional parameters
     * @param {module:model/StopSpamThrottlerRequest} opts.stopSpamThrottlerRequest 
     * @param {module:api/AdminApi~stopSpamThrottlerCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/StopSpamThrottler200Response}
     */
  }, {
    key: "stopSpamThrottler",
    value: function stopSpamThrottler(opts, callback) {
      opts = opts || {};
      var postBody = new _StopSpamThrottlerRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _StopSpamThrottler200Response["default"];
      return this.apiClient.callApi('/admin/stopSpamThrottler', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the stopStateMigration operation.
     * @callback module:api/AdminApi~stopStateMigrationCallback
     * @param {String} error Error message, if any.
     * @param {module:model/StopStateMigration200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [stopStateMigration]
     * The stopStateMigration is an administrative method that stops the currently running state migration. This method takes no parameters and returns null or an error whether the state migration was stopped or not.         **JSONRPC:** `admin_stopStateMigration` 
     * @param {Object} opts Optional parameters
     * @param {module:model/StopStateMigrationRequest} opts.stopStateMigrationRequest 
     * @param {module:api/AdminApi~stopStateMigrationCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/StopStateMigration200Response}
     */
  }, {
    key: "stopStateMigration",
    value: function stopStateMigration(opts, callback) {
      opts = opts || {};
      var postBody = new _StopStateMigrationRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _StopStateMigration200Response["default"];
      return this.apiClient.callApi('/admin/stopStateMigration', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the stopWS operation.
     * @callback module:api/AdminApi~stopWSCallback
     * @param {String} error Error message, if any.
     * @param {module:model/StopWS200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [stopWS]
     * The stopWS is an administrative method that closes the currently open WebSocket RPC endpoint. As the node can only have a single WebSocket endpoint running, this method takes no parameters, returning a boolean whether the endpoint was closed or not.          **JSONRPC:** `admin_stopWS` 
     * @param {Object} opts Optional parameters
     * @param {module:model/StopWSRequest} opts.stopWSRequest 
     * @param {module:api/AdminApi~stopWSCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/StopWS200Response}
     */
  }, {
    key: "stopWS",
    value: function stopWS(opts, callback) {
      opts = opts || {};
      var postBody = new _StopWSRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _StopWS200Response["default"];
      return this.apiClient.callApi('/admin/stopWS', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }
  }]);
  return AdminApi;
}();