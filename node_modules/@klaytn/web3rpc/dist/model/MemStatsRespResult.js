"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _ApiClient = _interopRequireDefault(require("../ApiClient"));
var _MemStatsRespResultBySizeInner = _interopRequireDefault(require("./MemStatsRespResultBySizeInner"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }
function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }
function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i]; return arr2; }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); } /**
 * web3rpc
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.9.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */
/**
 * The MemStatsRespResult model module.
 * @module model/MemStatsRespResult
 * @version 0.9.8
 */
var MemStatsRespResult = /*#__PURE__*/function () {
  /**
   * Constructs a new <code>MemStatsRespResult</code>.
   * Returns detailed runtime memory statistics.
   * @alias module:model/MemStatsRespResult
   * @param alloc {String} Alloc is bytes of allocated heap objects. This is the same as HeapAlloc
   * @param totalAlloc {String} TotalAlloc is cumulative bytes allocated for heap objects. TotalAlloc increases as heap objects are allocated, but unlike Alloc and HeapAlloc, it does not decrease when objects are freed.
   * @param sys {String} Sys is the total bytes of memory obtained from the OS. Sys is the sum of the XSys fields below. Sys measures the virtual address space reserved by the Go runtime for the heap, stacks, and other internal data structures. It's likely that not all of the virtual address space is backed by physical memory at any given moment, though in general it all was at some point.
   * @param lookups {String} Lookups is the number of pointer lookups performed by the runtime. This is primarily useful for debugging runtime internals
   * @param mallocs {String} Mallocs is the cumulative count of heap objects allocated. The number of live objects is Mallocs - Frees.
   * @param frees {String} Frees is the cumulative count of heap objects freed.
   * @param heapAlloc {String} HeapAlloc is bytes of allocated heap objects. \"Allocated\" heap objects include all reachable objects, as well as unreachable objects that the garbage collector has not yet freed. Specifically, HeapAlloc increases as heap objects are allocated and decreases as the heap is swept and unreachable objects are freed. Sweeping occurs incrementally between GC cycles, so these two processes occur simultaneously, and as a result HeapAlloc tends to change smoothly (in contrast with the sawtooth that is typical of stop-the-world garbage collectors).
   * @param heapSys {String} HeapSys is bytes of heap memory obtained from the OS. HeapSys measures the amount of virtual address space reserved for the heap. This includes virtual address space that has been reserved but not yet used, which consumes no physical memory, but tends to be small, as well as virtual address space for which the physical memory has been returned to the OS after it became unused (see HeapReleased for a measure of the latter). HeapSys estimates the largest size the heap has had.
   * @param heapIdle {String} HeapIdle is bytes in idle (unused) spans. Idle spans have no objects in them. These spans could be (and may already have been) returned to the OS, or they can be reused for heap allocations, or they can be reused as stack memory. HeapIdle minus HeapReleased estimates the amount of memory that could be returned to the OS, but is being retained by the runtime so it can grow the heap without requesting more memory from the OS. If this difference is significantly larger than the heap size, it indicates there was a recent transient spike in live heap size.
   * @param heapInuse {String} HeapInuse is bytes in in-use spans. In-use spans have at least one object in them. These spans can only be used for other objects of roughly the same size. HeapInuse minus HeapAlloc estimates the amount of memory that has been dedicated to particular size classes, but is not currently being used. This is an upper bound on fragmentation, but in general this memory can be reused efficiently.
   * @param heapReleased {String} HeapReleased is bytes of physical memory returned to the OS. This counts heap memory from idle spans that was returned to the OS and has not yet been reacquired for the heap.
   * @param heapObjects {String} HeapObjects is the number of allocated heap objects. Like HeapAlloc, this increases as objects are allocated and decreases as the heap is swept and unreachable objects are freed
   * @param stackInuse {String} StackInuse is bytes in stack spans. In-use stack spans have at least one stack in them. These spans can only be used for other stacks of the same size. There is no StackIdle because unused stack spans are returned to the heap (and hence counted toward HeapIdle).
   * @param stackSys {String} StackSys is bytes of stack memory obtained from the OS. StackSys is StackInuse, plus any memory obtained directly from the OS for OS thread stacks (which should be minimal).
   * @param mSpanSys {String} MSpanSys is bytes of memory obtained from the OS for mspan structures.
   * @param mSpanInuse {String} MCacheInuse is bytes of allocated mcache structures.
   * @param mCacheSys {String} MCacheSys is bytes of memory obtained from the OS for mcache structures.
   * @param buckHashSys {String} BuckHashSys is bytes of memory in profiling bucket hash tables.
   * @param gCSys {String} GCSys is bytes of memory in garbage collection metadata.
   * @param otherSys {String} OtherSys is bytes of memory in miscellaneous off-heap runtime allocations.
   * @param nextGC {String} NextGC is the target heap size of the next GC cycle. The garbage collector's goal is to keep HeapAlloc â‰¤ NextGC. At the end of each GC cycle, the target for the next cycle is computed based on the amount of reachable data and the value of GOGC.
   * @param lastGC {String} LastGC is the time the last garbage collection finished, as nanoseconds since 1970 (the UNIX epoch).
   * @param pauseTotalNs {String} PauseTotalNs is the cumulative nanoseconds in GC stop-the-world pauses since the program started. During a stop-the-world pause, all goroutines are paused and only the garbage collector can run.
   * @param pauseNs {Array.<String>} PauseNs is a circular buffer of recent GC stop-the-world pause times in nanoseconds. The most recent pause is at PauseNs[(NumGC+255)%256]. In general, PauseNs[N%256] records the time paused in the most recent N%256th GC cycle. There may be multiple pauses per GC cycle; this is the sum of all pauses during a cycle.
   * @param pauseEnd {Array.<String>} PauseEnd is a circular buffer of recent GC pause end times, as nanoseconds since 1970 (the UNIX epoch). This buffer is filled the same way as PauseNs. There may be multiple pauses per GC cycle; this records the end of the last pause in a cycle.
   * @param numGC {String} NumGC is the number of completed GC cycles.
   * @param numForcedGC {String} NumForcedGC is the number of GC cycles that were forced by the application calling the GC function.
   * @param gCCPUFraction {String} GCCPUFraction is the fraction of this program's available CPU time used by the GC since the program started. GCCPUFraction is expressed as a number between 0 and 1, where 0 means GC has consumed none of this program's CPU. A program's available CPU time is defined as the integral of GOMAXPROCS since the program started. That is, if GOMAXPROCS is 2 and a program has been running for 10 seconds, its \"available CPU\" is 20 seconds. GCCPUFraction does not include CPU time used for write barrier activity. This is the same as the fraction of CPU reported by GODEBUG=gctrace=1.
   * @param enableGC {Boolean} EnableGC indicates that GC is enabled. It is always true, even if GOGC=off.
   * @param debugGC {Boolean} DebugGC is currently unused.
   * @param bySize {Array.<module:model/MemStatsRespResultBySizeInner>} BySize reports per-size class allocation statistics. BySize[N] gives statistics for allocations of size S where BySize[N-1].Size < S â‰¤ BySize[N].Size. This does not report allocations larger than BySize[60].Size.
   */
  function MemStatsRespResult(alloc, totalAlloc, sys, lookups, mallocs, frees, heapAlloc, heapSys, heapIdle, heapInuse, heapReleased, heapObjects, stackInuse, stackSys, mSpanSys, mSpanInuse, mCacheSys, buckHashSys, gCSys, otherSys, nextGC, lastGC, pauseTotalNs, pauseNs, pauseEnd, numGC, numForcedGC, gCCPUFraction, enableGC, debugGC, bySize) {
    _classCallCheck(this, MemStatsRespResult);
    MemStatsRespResult.initialize(this, alloc, totalAlloc, sys, lookups, mallocs, frees, heapAlloc, heapSys, heapIdle, heapInuse, heapReleased, heapObjects, stackInuse, stackSys, mSpanSys, mSpanInuse, mCacheSys, buckHashSys, gCSys, otherSys, nextGC, lastGC, pauseTotalNs, pauseNs, pauseEnd, numGC, numForcedGC, gCCPUFraction, enableGC, debugGC, bySize);
  }

  /**
   * Initializes the fields of this object.
   * This method is used by the constructors of any subclasses, in order to implement multiple inheritance (mix-ins).
   * Only for internal use.
   */
  _createClass(MemStatsRespResult, null, [{
    key: "initialize",
    value: function initialize(obj, alloc, totalAlloc, sys, lookups, mallocs, frees, heapAlloc, heapSys, heapIdle, heapInuse, heapReleased, heapObjects, stackInuse, stackSys, mSpanSys, mSpanInuse, mCacheSys, buckHashSys, gCSys, otherSys, nextGC, lastGC, pauseTotalNs, pauseNs, pauseEnd, numGC, numForcedGC, gCCPUFraction, enableGC, debugGC, bySize) {
      obj['Alloc'] = alloc;
      obj['TotalAlloc'] = totalAlloc;
      obj['Sys'] = sys;
      obj['Lookups'] = lookups;
      obj['Mallocs'] = mallocs;
      obj['Frees'] = frees;
      obj['HeapAlloc'] = heapAlloc;
      obj['HeapSys'] = heapSys;
      obj['HeapIdle'] = heapIdle;
      obj['HeapInuse'] = heapInuse;
      obj['HeapReleased'] = heapReleased;
      obj['HeapObjects'] = heapObjects;
      obj['StackInuse'] = stackInuse;
      obj['StackSys'] = stackSys;
      obj['MSpanSys'] = mSpanSys;
      obj['MSpanInuse'] = mSpanInuse;
      obj['MCacheSys'] = mCacheSys;
      obj['BuckHashSys'] = buckHashSys;
      obj['GCSys'] = gCSys;
      obj['OtherSys'] = otherSys;
      obj['NextGC'] = nextGC;
      obj['LastGC'] = lastGC;
      obj['PauseTotalNs'] = pauseTotalNs;
      obj['PauseNs'] = pauseNs;
      obj['PauseEnd'] = pauseEnd;
      obj['NumGC'] = numGC;
      obj['NumForcedGC'] = numForcedGC;
      obj['GCCPUFraction'] = gCCPUFraction;
      obj['EnableGC'] = enableGC;
      obj['DebugGC'] = debugGC;
      obj['BySize'] = bySize;
    }

    /**
     * Constructs a <code>MemStatsRespResult</code> from a plain JavaScript object, optionally creating a new instance.
     * Copies all relevant properties from <code>data</code> to <code>obj</code> if supplied or a new instance if not.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @param {module:model/MemStatsRespResult} obj Optional instance to populate.
     * @return {module:model/MemStatsRespResult} The populated <code>MemStatsRespResult</code> instance.
     */
  }, {
    key: "constructFromObject",
    value: function constructFromObject(data, obj) {
      if (data) {
        obj = obj || new MemStatsRespResult();
        if (data.hasOwnProperty('Alloc')) {
          obj['Alloc'] = _ApiClient["default"].convertToType(data['Alloc'], 'String');
        }
        if (data.hasOwnProperty('TotalAlloc')) {
          obj['TotalAlloc'] = _ApiClient["default"].convertToType(data['TotalAlloc'], 'String');
        }
        if (data.hasOwnProperty('Sys')) {
          obj['Sys'] = _ApiClient["default"].convertToType(data['Sys'], 'String');
        }
        if (data.hasOwnProperty('Lookups')) {
          obj['Lookups'] = _ApiClient["default"].convertToType(data['Lookups'], 'String');
        }
        if (data.hasOwnProperty('Mallocs')) {
          obj['Mallocs'] = _ApiClient["default"].convertToType(data['Mallocs'], 'String');
        }
        if (data.hasOwnProperty('Frees')) {
          obj['Frees'] = _ApiClient["default"].convertToType(data['Frees'], 'String');
        }
        if (data.hasOwnProperty('HeapAlloc')) {
          obj['HeapAlloc'] = _ApiClient["default"].convertToType(data['HeapAlloc'], 'String');
        }
        if (data.hasOwnProperty('HeapSys')) {
          obj['HeapSys'] = _ApiClient["default"].convertToType(data['HeapSys'], 'String');
        }
        if (data.hasOwnProperty('HeapIdle')) {
          obj['HeapIdle'] = _ApiClient["default"].convertToType(data['HeapIdle'], 'String');
        }
        if (data.hasOwnProperty('HeapInuse')) {
          obj['HeapInuse'] = _ApiClient["default"].convertToType(data['HeapInuse'], 'String');
        }
        if (data.hasOwnProperty('HeapReleased')) {
          obj['HeapReleased'] = _ApiClient["default"].convertToType(data['HeapReleased'], 'String');
        }
        if (data.hasOwnProperty('HeapObjects')) {
          obj['HeapObjects'] = _ApiClient["default"].convertToType(data['HeapObjects'], 'String');
        }
        if (data.hasOwnProperty('StackInuse')) {
          obj['StackInuse'] = _ApiClient["default"].convertToType(data['StackInuse'], 'String');
        }
        if (data.hasOwnProperty('StackSys')) {
          obj['StackSys'] = _ApiClient["default"].convertToType(data['StackSys'], 'String');
        }
        if (data.hasOwnProperty('MSpanSys')) {
          obj['MSpanSys'] = _ApiClient["default"].convertToType(data['MSpanSys'], 'String');
        }
        if (data.hasOwnProperty('MSpanInuse')) {
          obj['MSpanInuse'] = _ApiClient["default"].convertToType(data['MSpanInuse'], 'String');
        }
        if (data.hasOwnProperty('MCacheSys')) {
          obj['MCacheSys'] = _ApiClient["default"].convertToType(data['MCacheSys'], 'String');
        }
        if (data.hasOwnProperty('BuckHashSys')) {
          obj['BuckHashSys'] = _ApiClient["default"].convertToType(data['BuckHashSys'], 'String');
        }
        if (data.hasOwnProperty('GCSys')) {
          obj['GCSys'] = _ApiClient["default"].convertToType(data['GCSys'], 'String');
        }
        if (data.hasOwnProperty('OtherSys')) {
          obj['OtherSys'] = _ApiClient["default"].convertToType(data['OtherSys'], 'String');
        }
        if (data.hasOwnProperty('NextGC')) {
          obj['NextGC'] = _ApiClient["default"].convertToType(data['NextGC'], 'String');
        }
        if (data.hasOwnProperty('LastGC')) {
          obj['LastGC'] = _ApiClient["default"].convertToType(data['LastGC'], 'String');
        }
        if (data.hasOwnProperty('PauseTotalNs')) {
          obj['PauseTotalNs'] = _ApiClient["default"].convertToType(data['PauseTotalNs'], 'String');
        }
        if (data.hasOwnProperty('PauseNs')) {
          obj['PauseNs'] = _ApiClient["default"].convertToType(data['PauseNs'], ['String']);
        }
        if (data.hasOwnProperty('PauseEnd')) {
          obj['PauseEnd'] = _ApiClient["default"].convertToType(data['PauseEnd'], ['String']);
        }
        if (data.hasOwnProperty('NumGC')) {
          obj['NumGC'] = _ApiClient["default"].convertToType(data['NumGC'], 'String');
        }
        if (data.hasOwnProperty('NumForcedGC')) {
          obj['NumForcedGC'] = _ApiClient["default"].convertToType(data['NumForcedGC'], 'String');
        }
        if (data.hasOwnProperty('GCCPUFraction')) {
          obj['GCCPUFraction'] = _ApiClient["default"].convertToType(data['GCCPUFraction'], 'String');
        }
        if (data.hasOwnProperty('EnableGC')) {
          obj['EnableGC'] = _ApiClient["default"].convertToType(data['EnableGC'], 'Boolean');
        }
        if (data.hasOwnProperty('DebugGC')) {
          obj['DebugGC'] = _ApiClient["default"].convertToType(data['DebugGC'], 'Boolean');
        }
        if (data.hasOwnProperty('BySize')) {
          obj['BySize'] = _ApiClient["default"].convertToType(data['BySize'], [_MemStatsRespResultBySizeInner["default"]]);
        }
      }
      return obj;
    }

    /**
     * Validates the JSON data with respect to <code>MemStatsRespResult</code>.
     * @param {Object} data The plain JavaScript object bearing properties of interest.
     * @return {boolean} to indicate whether the JSON data is valid with respect to <code>MemStatsRespResult</code>.
     */
  }, {
    key: "validateJSON",
    value: function validateJSON(data) {
      // check to make sure all required properties are present in the JSON string
      var _iterator = _createForOfIteratorHelper(MemStatsRespResult.RequiredProperties),
        _step;
      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var property = _step.value;
          if (!data[property]) {
            throw new Error("The required field `" + property + "` is not found in the JSON data: " + JSON.stringify(data));
          }
        }
        // ensure the json data is a string
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
      if (data['Alloc'] && !(typeof data['Alloc'] === 'string' || data['Alloc'] instanceof String)) {
        throw new Error("Expected the field `Alloc` to be a primitive type in the JSON string but got " + data['Alloc']);
      }
      // ensure the json data is a string
      if (data['TotalAlloc'] && !(typeof data['TotalAlloc'] === 'string' || data['TotalAlloc'] instanceof String)) {
        throw new Error("Expected the field `TotalAlloc` to be a primitive type in the JSON string but got " + data['TotalAlloc']);
      }
      // ensure the json data is a string
      if (data['Sys'] && !(typeof data['Sys'] === 'string' || data['Sys'] instanceof String)) {
        throw new Error("Expected the field `Sys` to be a primitive type in the JSON string but got " + data['Sys']);
      }
      // ensure the json data is a string
      if (data['Lookups'] && !(typeof data['Lookups'] === 'string' || data['Lookups'] instanceof String)) {
        throw new Error("Expected the field `Lookups` to be a primitive type in the JSON string but got " + data['Lookups']);
      }
      // ensure the json data is a string
      if (data['Mallocs'] && !(typeof data['Mallocs'] === 'string' || data['Mallocs'] instanceof String)) {
        throw new Error("Expected the field `Mallocs` to be a primitive type in the JSON string but got " + data['Mallocs']);
      }
      // ensure the json data is a string
      if (data['Frees'] && !(typeof data['Frees'] === 'string' || data['Frees'] instanceof String)) {
        throw new Error("Expected the field `Frees` to be a primitive type in the JSON string but got " + data['Frees']);
      }
      // ensure the json data is a string
      if (data['HeapAlloc'] && !(typeof data['HeapAlloc'] === 'string' || data['HeapAlloc'] instanceof String)) {
        throw new Error("Expected the field `HeapAlloc` to be a primitive type in the JSON string but got " + data['HeapAlloc']);
      }
      // ensure the json data is a string
      if (data['HeapSys'] && !(typeof data['HeapSys'] === 'string' || data['HeapSys'] instanceof String)) {
        throw new Error("Expected the field `HeapSys` to be a primitive type in the JSON string but got " + data['HeapSys']);
      }
      // ensure the json data is a string
      if (data['HeapIdle'] && !(typeof data['HeapIdle'] === 'string' || data['HeapIdle'] instanceof String)) {
        throw new Error("Expected the field `HeapIdle` to be a primitive type in the JSON string but got " + data['HeapIdle']);
      }
      // ensure the json data is a string
      if (data['HeapInuse'] && !(typeof data['HeapInuse'] === 'string' || data['HeapInuse'] instanceof String)) {
        throw new Error("Expected the field `HeapInuse` to be a primitive type in the JSON string but got " + data['HeapInuse']);
      }
      // ensure the json data is a string
      if (data['HeapReleased'] && !(typeof data['HeapReleased'] === 'string' || data['HeapReleased'] instanceof String)) {
        throw new Error("Expected the field `HeapReleased` to be a primitive type in the JSON string but got " + data['HeapReleased']);
      }
      // ensure the json data is a string
      if (data['HeapObjects'] && !(typeof data['HeapObjects'] === 'string' || data['HeapObjects'] instanceof String)) {
        throw new Error("Expected the field `HeapObjects` to be a primitive type in the JSON string but got " + data['HeapObjects']);
      }
      // ensure the json data is a string
      if (data['StackInuse'] && !(typeof data['StackInuse'] === 'string' || data['StackInuse'] instanceof String)) {
        throw new Error("Expected the field `StackInuse` to be a primitive type in the JSON string but got " + data['StackInuse']);
      }
      // ensure the json data is a string
      if (data['StackSys'] && !(typeof data['StackSys'] === 'string' || data['StackSys'] instanceof String)) {
        throw new Error("Expected the field `StackSys` to be a primitive type in the JSON string but got " + data['StackSys']);
      }
      // ensure the json data is a string
      if (data['MSpanSys'] && !(typeof data['MSpanSys'] === 'string' || data['MSpanSys'] instanceof String)) {
        throw new Error("Expected the field `MSpanSys` to be a primitive type in the JSON string but got " + data['MSpanSys']);
      }
      // ensure the json data is a string
      if (data['MSpanInuse'] && !(typeof data['MSpanInuse'] === 'string' || data['MSpanInuse'] instanceof String)) {
        throw new Error("Expected the field `MSpanInuse` to be a primitive type in the JSON string but got " + data['MSpanInuse']);
      }
      // ensure the json data is a string
      if (data['MCacheSys'] && !(typeof data['MCacheSys'] === 'string' || data['MCacheSys'] instanceof String)) {
        throw new Error("Expected the field `MCacheSys` to be a primitive type in the JSON string but got " + data['MCacheSys']);
      }
      // ensure the json data is a string
      if (data['BuckHashSys'] && !(typeof data['BuckHashSys'] === 'string' || data['BuckHashSys'] instanceof String)) {
        throw new Error("Expected the field `BuckHashSys` to be a primitive type in the JSON string but got " + data['BuckHashSys']);
      }
      // ensure the json data is a string
      if (data['GCSys'] && !(typeof data['GCSys'] === 'string' || data['GCSys'] instanceof String)) {
        throw new Error("Expected the field `GCSys` to be a primitive type in the JSON string but got " + data['GCSys']);
      }
      // ensure the json data is a string
      if (data['OtherSys'] && !(typeof data['OtherSys'] === 'string' || data['OtherSys'] instanceof String)) {
        throw new Error("Expected the field `OtherSys` to be a primitive type in the JSON string but got " + data['OtherSys']);
      }
      // ensure the json data is a string
      if (data['NextGC'] && !(typeof data['NextGC'] === 'string' || data['NextGC'] instanceof String)) {
        throw new Error("Expected the field `NextGC` to be a primitive type in the JSON string but got " + data['NextGC']);
      }
      // ensure the json data is a string
      if (data['LastGC'] && !(typeof data['LastGC'] === 'string' || data['LastGC'] instanceof String)) {
        throw new Error("Expected the field `LastGC` to be a primitive type in the JSON string but got " + data['LastGC']);
      }
      // ensure the json data is a string
      if (data['PauseTotalNs'] && !(typeof data['PauseTotalNs'] === 'string' || data['PauseTotalNs'] instanceof String)) {
        throw new Error("Expected the field `PauseTotalNs` to be a primitive type in the JSON string but got " + data['PauseTotalNs']);
      }
      // ensure the json data is an array
      if (!Array.isArray(data['PauseNs'])) {
        throw new Error("Expected the field `PauseNs` to be an array in the JSON data but got " + data['PauseNs']);
      }
      // ensure the json data is an array
      if (!Array.isArray(data['PauseEnd'])) {
        throw new Error("Expected the field `PauseEnd` to be an array in the JSON data but got " + data['PauseEnd']);
      }
      // ensure the json data is a string
      if (data['NumGC'] && !(typeof data['NumGC'] === 'string' || data['NumGC'] instanceof String)) {
        throw new Error("Expected the field `NumGC` to be a primitive type in the JSON string but got " + data['NumGC']);
      }
      // ensure the json data is a string
      if (data['NumForcedGC'] && !(typeof data['NumForcedGC'] === 'string' || data['NumForcedGC'] instanceof String)) {
        throw new Error("Expected the field `NumForcedGC` to be a primitive type in the JSON string but got " + data['NumForcedGC']);
      }
      // ensure the json data is a string
      if (data['GCCPUFraction'] && !(typeof data['GCCPUFraction'] === 'string' || data['GCCPUFraction'] instanceof String)) {
        throw new Error("Expected the field `GCCPUFraction` to be a primitive type in the JSON string but got " + data['GCCPUFraction']);
      }
      if (data['BySize']) {
        // data not null
        // ensure the json data is an array
        if (!Array.isArray(data['BySize'])) {
          throw new Error("Expected the field `BySize` to be an array in the JSON data but got " + data['BySize']);
        }
        // validate the optional field `BySize` (array)
        var _iterator2 = _createForOfIteratorHelper(data['BySize']),
          _step2;
        try {
          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {
            var item = _step2.value;
            _MemStatsRespResultBySizeInner["default"].validateJsonObject(item);
          }
        } catch (err) {
          _iterator2.e(err);
        } finally {
          _iterator2.f();
        }
        ;
      }
      return true;
    }
  }]);
  return MemStatsRespResult;
}();
MemStatsRespResult.RequiredProperties = ["Alloc", "TotalAlloc", "Sys", "Lookups", "Mallocs", "Frees", "HeapAlloc", "HeapSys", "HeapIdle", "HeapInuse", "HeapReleased", "HeapObjects", "StackInuse", "StackSys", "MSpanSys", "MSpanInuse", "MCacheSys", "BuckHashSys", "GCSys", "OtherSys", "NextGC", "LastGC", "PauseTotalNs", "PauseNs", "PauseEnd", "NumGC", "NumForcedGC", "GCCPUFraction", "EnableGC", "DebugGC", "BySize"];

/**
 * Alloc is bytes of allocated heap objects. This is the same as HeapAlloc
 * @member {String} Alloc
 */
MemStatsRespResult.prototype['Alloc'] = undefined;

/**
 * TotalAlloc is cumulative bytes allocated for heap objects. TotalAlloc increases as heap objects are allocated, but unlike Alloc and HeapAlloc, it does not decrease when objects are freed.
 * @member {String} TotalAlloc
 */
MemStatsRespResult.prototype['TotalAlloc'] = undefined;

/**
 * Sys is the total bytes of memory obtained from the OS. Sys is the sum of the XSys fields below. Sys measures the virtual address space reserved by the Go runtime for the heap, stacks, and other internal data structures. It's likely that not all of the virtual address space is backed by physical memory at any given moment, though in general it all was at some point.
 * @member {String} Sys
 */
MemStatsRespResult.prototype['Sys'] = undefined;

/**
 * Lookups is the number of pointer lookups performed by the runtime. This is primarily useful for debugging runtime internals
 * @member {String} Lookups
 */
MemStatsRespResult.prototype['Lookups'] = undefined;

/**
 * Mallocs is the cumulative count of heap objects allocated. The number of live objects is Mallocs - Frees.
 * @member {String} Mallocs
 */
MemStatsRespResult.prototype['Mallocs'] = undefined;

/**
 * Frees is the cumulative count of heap objects freed.
 * @member {String} Frees
 */
MemStatsRespResult.prototype['Frees'] = undefined;

/**
 * HeapAlloc is bytes of allocated heap objects. \"Allocated\" heap objects include all reachable objects, as well as unreachable objects that the garbage collector has not yet freed. Specifically, HeapAlloc increases as heap objects are allocated and decreases as the heap is swept and unreachable objects are freed. Sweeping occurs incrementally between GC cycles, so these two processes occur simultaneously, and as a result HeapAlloc tends to change smoothly (in contrast with the sawtooth that is typical of stop-the-world garbage collectors).
 * @member {String} HeapAlloc
 */
MemStatsRespResult.prototype['HeapAlloc'] = undefined;

/**
 * HeapSys is bytes of heap memory obtained from the OS. HeapSys measures the amount of virtual address space reserved for the heap. This includes virtual address space that has been reserved but not yet used, which consumes no physical memory, but tends to be small, as well as virtual address space for which the physical memory has been returned to the OS after it became unused (see HeapReleased for a measure of the latter). HeapSys estimates the largest size the heap has had.
 * @member {String} HeapSys
 */
MemStatsRespResult.prototype['HeapSys'] = undefined;

/**
 * HeapIdle is bytes in idle (unused) spans. Idle spans have no objects in them. These spans could be (and may already have been) returned to the OS, or they can be reused for heap allocations, or they can be reused as stack memory. HeapIdle minus HeapReleased estimates the amount of memory that could be returned to the OS, but is being retained by the runtime so it can grow the heap without requesting more memory from the OS. If this difference is significantly larger than the heap size, it indicates there was a recent transient spike in live heap size.
 * @member {String} HeapIdle
 */
MemStatsRespResult.prototype['HeapIdle'] = undefined;

/**
 * HeapInuse is bytes in in-use spans. In-use spans have at least one object in them. These spans can only be used for other objects of roughly the same size. HeapInuse minus HeapAlloc estimates the amount of memory that has been dedicated to particular size classes, but is not currently being used. This is an upper bound on fragmentation, but in general this memory can be reused efficiently.
 * @member {String} HeapInuse
 */
MemStatsRespResult.prototype['HeapInuse'] = undefined;

/**
 * HeapReleased is bytes of physical memory returned to the OS. This counts heap memory from idle spans that was returned to the OS and has not yet been reacquired for the heap.
 * @member {String} HeapReleased
 */
MemStatsRespResult.prototype['HeapReleased'] = undefined;

/**
 * HeapObjects is the number of allocated heap objects. Like HeapAlloc, this increases as objects are allocated and decreases as the heap is swept and unreachable objects are freed
 * @member {String} HeapObjects
 */
MemStatsRespResult.prototype['HeapObjects'] = undefined;

/**
 * StackInuse is bytes in stack spans. In-use stack spans have at least one stack in them. These spans can only be used for other stacks of the same size. There is no StackIdle because unused stack spans are returned to the heap (and hence counted toward HeapIdle).
 * @member {String} StackInuse
 */
MemStatsRespResult.prototype['StackInuse'] = undefined;

/**
 * StackSys is bytes of stack memory obtained from the OS. StackSys is StackInuse, plus any memory obtained directly from the OS for OS thread stacks (which should be minimal).
 * @member {String} StackSys
 */
MemStatsRespResult.prototype['StackSys'] = undefined;

/**
 * MSpanSys is bytes of memory obtained from the OS for mspan structures.
 * @member {String} MSpanSys
 */
MemStatsRespResult.prototype['MSpanSys'] = undefined;

/**
 * MCacheInuse is bytes of allocated mcache structures.
 * @member {String} MSpanInuse
 */
MemStatsRespResult.prototype['MSpanInuse'] = undefined;

/**
 * MCacheSys is bytes of memory obtained from the OS for mcache structures.
 * @member {String} MCacheSys
 */
MemStatsRespResult.prototype['MCacheSys'] = undefined;

/**
 * BuckHashSys is bytes of memory in profiling bucket hash tables.
 * @member {String} BuckHashSys
 */
MemStatsRespResult.prototype['BuckHashSys'] = undefined;

/**
 * GCSys is bytes of memory in garbage collection metadata.
 * @member {String} GCSys
 */
MemStatsRespResult.prototype['GCSys'] = undefined;

/**
 * OtherSys is bytes of memory in miscellaneous off-heap runtime allocations.
 * @member {String} OtherSys
 */
MemStatsRespResult.prototype['OtherSys'] = undefined;

/**
 * NextGC is the target heap size of the next GC cycle. The garbage collector's goal is to keep HeapAlloc â‰¤ NextGC. At the end of each GC cycle, the target for the next cycle is computed based on the amount of reachable data and the value of GOGC.
 * @member {String} NextGC
 */
MemStatsRespResult.prototype['NextGC'] = undefined;

/**
 * LastGC is the time the last garbage collection finished, as nanoseconds since 1970 (the UNIX epoch).
 * @member {String} LastGC
 */
MemStatsRespResult.prototype['LastGC'] = undefined;

/**
 * PauseTotalNs is the cumulative nanoseconds in GC stop-the-world pauses since the program started. During a stop-the-world pause, all goroutines are paused and only the garbage collector can run.
 * @member {String} PauseTotalNs
 */
MemStatsRespResult.prototype['PauseTotalNs'] = undefined;

/**
 * PauseNs is a circular buffer of recent GC stop-the-world pause times in nanoseconds. The most recent pause is at PauseNs[(NumGC+255)%256]. In general, PauseNs[N%256] records the time paused in the most recent N%256th GC cycle. There may be multiple pauses per GC cycle; this is the sum of all pauses during a cycle.
 * @member {Array.<String>} PauseNs
 */
MemStatsRespResult.prototype['PauseNs'] = undefined;

/**
 * PauseEnd is a circular buffer of recent GC pause end times, as nanoseconds since 1970 (the UNIX epoch). This buffer is filled the same way as PauseNs. There may be multiple pauses per GC cycle; this records the end of the last pause in a cycle.
 * @member {Array.<String>} PauseEnd
 */
MemStatsRespResult.prototype['PauseEnd'] = undefined;

/**
 * NumGC is the number of completed GC cycles.
 * @member {String} NumGC
 */
MemStatsRespResult.prototype['NumGC'] = undefined;

/**
 * NumForcedGC is the number of GC cycles that were forced by the application calling the GC function.
 * @member {String} NumForcedGC
 */
MemStatsRespResult.prototype['NumForcedGC'] = undefined;

/**
 * GCCPUFraction is the fraction of this program's available CPU time used by the GC since the program started. GCCPUFraction is expressed as a number between 0 and 1, where 0 means GC has consumed none of this program's CPU. A program's available CPU time is defined as the integral of GOMAXPROCS since the program started. That is, if GOMAXPROCS is 2 and a program has been running for 10 seconds, its \"available CPU\" is 20 seconds. GCCPUFraction does not include CPU time used for write barrier activity. This is the same as the fraction of CPU reported by GODEBUG=gctrace=1.
 * @member {String} GCCPUFraction
 */
MemStatsRespResult.prototype['GCCPUFraction'] = undefined;

/**
 * EnableGC indicates that GC is enabled. It is always true, even if GOGC=off.
 * @member {Boolean} EnableGC
 */
MemStatsRespResult.prototype['EnableGC'] = undefined;

/**
 * DebugGC is currently unused.
 * @member {Boolean} DebugGC
 */
MemStatsRespResult.prototype['DebugGC'] = undefined;

/**
 * BySize reports per-size class allocation statistics. BySize[N] gives statistics for allocations of size S where BySize[N-1].Size < S â‰¤ BySize[N].Size. This does not report allocations larger than BySize[60].Size.
 * @member {Array.<module:model/MemStatsRespResultBySizeInner>} BySize
 */
MemStatsRespResult.prototype['BySize'] = undefined;
var _default = exports["default"] = MemStatsRespResult;