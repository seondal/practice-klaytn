"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getSignatureTuple = exports.getCompressedPublicKey = void 0;
const bytes_1 = require("@ethersproject/bytes");
const elliptic_1 = require("elliptic");
const lodash_1 = __importDefault(require("lodash"));
const data_1 = require("./data");
const secp256k1 = new elliptic_1.ec("secp256k1");
// Returns a 33-byte compressed public key from
// a compressed (33-byte) or uncompressed (65-byte) public key.
function getCompressedPublicKey(pub) {
    const hex = data_1.HexStr.from(pub);
    if (data_1.HexStr.isHex(hex, 33) || data_1.HexStr.isHex(hex, 65)) {
        const pub = secp256k1.keyFromPublic(hex.substring(2), "hex");
        return "0x" + pub.getPublic(true, "hex");
    }
    else {
        throw new Error("Public key must be 33 or 65 bytes");
    }
}
exports.getCompressedPublicKey = getCompressedPublicKey;
// If the sig is an array, the first element 'v' must be one of:
// - pre-EIP-155 v: {27, 28}
// - EIP-155 v: {27, 28} + chainId*8 + 2
//
// If the sig is in object form, it must have one of:
// - sig.recoveryParam: {0, 1}
// - sig.v
//   - pre-EIP-155 v: {27, 28}
//   - EIP-155 v: {27, 28} + chainId*8 + 2
//
// If the sig is bytes, it must be 64 or 65 bytes.
//
// Returns a [v,r,s] tuple composed of only strings. For example, [
//   "0x1b",
//   "0x66809fb130a6ea4ae4e823baa92573a5f1bfb4e88e64048aecfb18a2b4012b99",
//   "0x75c2c3e5f7b0a182c767137c488649cd5104a5e747371fd922d618e328e5c508",
// ]
function getSignatureTuple(sig) {
    // For array, pass through splitSignature() for sanity check
    if (lodash_1.default.isArray(sig) && sig.length == 3) {
        const numV = data_1.HexStr.toNumber(sig[0]);
        sig = { v: numV, r: sig[1], s: sig[2] };
    }
    const split = (0, bytes_1.splitSignature)(sig);
    // R and S must not have leading zeros
    // c.f. https://github.com/ethers-io/ethers.js/blob/v5/packages/transactions/src.ts/index.ts#L298
    return [
        data_1.HexStr.fromNumber(split.v),
        data_1.HexStr.stripZeros(split.r),
        data_1.HexStr.stripZeros(split.s),
    ];
}
exports.getSignatureTuple = getSignatureTuple;
//# sourceMappingURL=ec.js.map