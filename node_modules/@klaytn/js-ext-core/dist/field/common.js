"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FieldTypeSignatureTuples = exports.FieldTypeBool = exports.FieldTypeUint256 = exports.FieldTypeUint64 = exports.FieldTypeUint32 = exports.FieldTypeUint8 = exports.FieldTypeNumberBits = exports.FieldTypeBytes = exports.FieldTypeAddress = exports.FieldError = void 0;
const address_1 = require("@ethersproject/address");
const bignumber_1 = require("@ethersproject/bignumber");
const lodash_1 = __importDefault(require("lodash"));
const util_1 = require("../util");
class FieldError extends Error {
    constructor(ty, name, value) {
        const message = `Cannot assign value '${value}' to field '${name}' of type '${ty.constructor.name}'`;
        super(message);
        this.name = "FieldError";
    }
}
exports.FieldError = FieldError;
// //////////////////////////////////////////////////////////
// Common field types
// Accepted types: hex string of an address
// Canonical type: hex string of checksumed address
exports.FieldTypeAddress = new class {
    canonicalize(value) {
        if (value === "0x") {
            return "0x";
        }
        return (0, address_1.getAddress)(value);
    }
    emptyValue() { return "0x"; }
};
// Accepted types: hex string, byte array
// Canonical type: hex string
exports.FieldTypeBytes = new class {
    canonicalize(value) { return util_1.HexStr.from(value); }
    emptyValue() { return "0x"; }
};
// Accepted types: JS number, JS bigint, BigNumber class, hex-encoded string
// Canonical type: hex string
class FieldTypeNumberBits {
    constructor(maxBits) {
        if (!maxBits) {
            maxBits = 256;
        }
        this.maxBits = maxBits;
        this.maxBN = bignumber_1.BigNumber.from(2).pow(maxBits);
    }
    canonicalize(value) {
        if (value === "0x") {
            value = 0;
        }
        const bn = bignumber_1.BigNumber.from(value);
        if (bn.gte(this.maxBN)) {
            throw new Error(`Number exceeds ${this.maxBits} bits`);
        }
        if (bn.isZero()) {
            // BigNumber.from(0).toHexString() returns '0x00',
            // but RLP encoder expects '0x'.
            return "0x";
        }
        return bn.toHexString();
    }
    emptyValue() { return "0x"; }
}
exports.FieldTypeNumberBits = FieldTypeNumberBits;
exports.FieldTypeUint8 = new FieldTypeNumberBits(8);
exports.FieldTypeUint32 = new FieldTypeNumberBits(32);
exports.FieldTypeUint64 = new FieldTypeNumberBits(64);
exports.FieldTypeUint256 = new FieldTypeNumberBits(256);
// Accepted types: boolean-like values, hex-encoded string
// Canonical type: "0x01" for true, "0x" for false
exports.FieldTypeBool = new class {
    canonicalize(value) {
        if (value === "0x01" || value === "0x") {
            return value;
        }
        return value ? "0x01" : "0x";
    }
    emptyValue() { return "0x"; }
};
// Accepted types: An array of [v,r,s] tuple, {v,r,s} object, serialized bytes
// Canonical type: An array of [v,r,s] tuple
exports.FieldTypeSignatureTuples = new class {
    canonicalize(value) {
        return lodash_1.default.map(value, util_1.getSignatureTuple);
    }
    emptyValue() { return []; }
};
//# sourceMappingURL=common.js.map