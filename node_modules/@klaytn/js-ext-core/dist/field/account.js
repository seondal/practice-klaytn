"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FieldTypeAccountKey = exports.FieldTypeAccountKeyList = exports.FieldTypeWeightedPublicKeys = exports.FieldTypeCompressedPubKey = void 0;
const lodash_1 = __importDefault(require("lodash"));
const accountkey_1 = require("../accountkey");
const util_1 = require("../util");
// Accepted types: A compressed (33-bytes) or uncompressed (65-bytes) public key
//                 in hex string or byte array
// Canonical type: A compressed (33-byte) public key in hex string
exports.FieldTypeCompressedPubKey = new class {
    canonicalize(value) {
        return (0, util_1.getCompressedPublicKey)(value);
    }
    emptyValue() { return "0x000000000000000000000000000000000000000000000000000000000000000000"; }
};
// Accepted types: An array of tuples [weight: number|string, publicKey: string]
// Canonical type: An array of hexlified tuples [weight: string, publicKey: string]
// Example canonical value:
// [
//   ["0x01", "0x02c734b50ddb229be5e929fc4aa8080ae8240a802d23d3290e5e6156ce029b110e"],
//   ["0x02", "0x0212d45f1cc56fbd6cd8fc877ab63b5092ac77db907a8a42c41dad3e98d7c64dfb"],
// ]
exports.FieldTypeWeightedPublicKeys = new class {
    _assert(value, pred) {
        if (!pred) {
            throw new Error(`Malformed WeightedPublicKeys '${value}'`);
        }
    }
    canonicalize(value) {
        this._assert(value, lodash_1.default.isArray(value));
        return lodash_1.default.map(value, (tuple) => {
            this._assert(value, lodash_1.default.isArray(tuple) && tuple.length == 2);
            const threshold = util_1.HexStr.fromNumber(tuple[0]);
            const publicKey = (0, util_1.getCompressedPublicKey)(tuple[1]);
            return [threshold, publicKey];
        });
    }
    emptyValue() { return []; }
};
// Accepted types: An array of AccountKeys in JS object format
// Canonical type: An array of AccountKeys in RLP format
// Example canonical value:
// [
//   "0x02a103e4a01407460c1c03ac0c82fd84f303a699b210c0b054f4aff72ff7dcdf01512d",
//   "0x04f84b02f848e301a103e4a01407460c1c03ac0c82fd84f303a699b210c0b054f4aff72ff7dcdf01512de301a10336f6355f5b532c3c1606f18fa2be7a16ae200c5159c8031dd25bfa389a4c9c06",
//   "0x02a102c8785266510368d9372badd4c7f4a94b692e82ba74e0b5e26b34558b0f081447",
// ]
exports.FieldTypeAccountKeyList = new class {
    _assert(value, pred) {
        if (!pred) {
            throw new Error(`Malformed RoleBasedKeys '${value}'`);
        }
    }
    canonicalize(value) {
        this._assert(value, lodash_1.default.isArray(value));
        return lodash_1.default.map(value, (elem) => {
            const accountKey = accountkey_1.AccountKeyFactory.fromObject(elem);
            if (!(0, util_1.isEmbeddableAccountKeyType)(accountKey.type)) {
                throw new Error(`AccountKeyType ${accountKey.type} cannot be inside an AccountKeyRoleBased`);
            }
            return accountKey.toRLP();
        });
    }
    emptyValue() { return []; }
};
// Accepted types: An AccountKey in JS object or RLP format
// Canonical type: An AccountKey in RLP format
// Example canonical value:
// "0x02a103e4a01407460c1c03ac0c82fd84f303a699b210c0b054f4aff72ff7dcdf01512d",
exports.FieldTypeAccountKey = new class {
    canonicalize(value) {
        if (lodash_1.default.isString(value) && util_1.HexStr.isHex(value)) { // pass RLP format
            return value;
        }
        else { // encode JS object format
            return accountkey_1.AccountKeyFactory.fromObject(value).toRLP();
        }
    }
    emptyValue() { return "0x80"; }
};
//# sourceMappingURL=account.js.map