"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _ApiClient = _interopRequireDefault(require("../ApiClient"));
var _Content200Response = _interopRequireDefault(require("../model/Content200Response"));
var _ContentRequest = _interopRequireDefault(require("../model/ContentRequest"));
var _Inspect200Response = _interopRequireDefault(require("../model/Inspect200Response"));
var _InspectRequest = _interopRequireDefault(require("../model/InspectRequest"));
var _Status200Response = _interopRequireDefault(require("../model/Status200Response"));
var _StatusRequest = _interopRequireDefault(require("../model/StatusRequest"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); } /**
 * web3rpc
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.9.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */
/**
* Txpool service.
* @module api/TxpoolApi
* @version 0.9.8
*/
var TxpoolApi = exports["default"] = /*#__PURE__*/function () {
  /**
  * Constructs a new TxpoolApi. 
  * @alias module:api/TxpoolApi
  * @class
  * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
  * default to {@link module:ApiClient#instance} if unspecified.
  */
  function TxpoolApi(apiClient) {
    _classCallCheck(this, TxpoolApi);
    this.apiClient = apiClient || _ApiClient["default"].instance;
  }

  /**
   * Callback function to receive the result of the content operation.
   * @callback module:api/TxpoolApi~contentCallback
   * @param {String} error Error message, if any.
   * @param {module:model/Content200Response} data The data returned by the service call.
   * @param {String} response The complete HTTP response.
   */

  /**
   * [content]
   * The content inspection property can be queried to list the exact details of all the transactions currently pending for inclusion in the next block(s), as well as the ones that are being scheduled for future execution only.  The result is an object with two fields pending and queued. Each of these fields is associative arrays, in which each entry maps an origin-address to a batch of scheduled transactions. These batches themselves are maps associating nonces with actual transactions.  **JSONRPC:** `txpool_content` 
   * @param {Object} opts Optional parameters
   * @param {module:model/ContentRequest} opts.contentRequest 
   * @param {module:api/TxpoolApi~contentCallback} callback The callback function, accepting three arguments: error, data, response
   * data is of type: {@link module:model/Content200Response}
   */
  _createClass(TxpoolApi, [{
    key: "content",
    value: function content(opts, callback) {
      opts = opts || {};
      var postBody = new _ContentRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _Content200Response["default"];
      return this.apiClient.callApi('/txpool/content', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the inspect operation.
     * @callback module:api/TxpoolApi~inspectCallback
     * @param {String} error Error message, if any.
     * @param {module:model/Inspect200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [inspect]
     * The inspect inspection property can be queried to list a textual summary of all the transactions currently pending for inclusion in the next block(s), as well as the ones that are being scheduled for future execution only. This is a method specifically tailored to developers to quickly see the transactions in the pool and find any potential issues.  The result is an object with two fields pending and queued. Each of these fields is associative arrays, in which each entry maps an origin-address to a batch of scheduled transactions. These batches themselves are maps associating nonces with transactions summary strings.  **JSONRPC:** `txpool_inspect` 
     * @param {Object} opts Optional parameters
     * @param {module:model/InspectRequest} opts.inspectRequest 
     * @param {module:api/TxpoolApi~inspectCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/Inspect200Response}
     */
  }, {
    key: "inspect",
    value: function inspect(opts, callback) {
      opts = opts || {};
      var postBody = new _InspectRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _Inspect200Response["default"];
      return this.apiClient.callApi('/txpool/inspect', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the status operation.
     * @callback module:api/TxpoolApi~statusCallback
     * @param {String} error Error message, if any.
     * @param {module:model/Status200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [status]
     * The status inspection property can be queried for the number of transactions currently pending for inclusion in the next block(s), as well as the ones that are being scheduled for future execution only.  The result is an object with two fields pending and queued, each of which is a counter representing the number of transactions in that particular state.  **JSONRPC:** `txpool_status` 
     * @param {Object} opts Optional parameters
     * @param {module:model/StatusRequest} opts.statusRequest 
     * @param {module:api/TxpoolApi~statusCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/Status200Response}
     */
  }, {
    key: "status",
    value: function status(opts, callback) {
      opts = opts || {};
      var postBody = new _StatusRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _Status200Response["default"];
      return this.apiClient.callApi('/txpool/status', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }
  }]);
  return TxpoolApi;
}();