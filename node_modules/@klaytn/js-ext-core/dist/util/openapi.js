"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.asyncOpenApi = exports.promisifyApi = exports.promisifyMethod = exports.JsonRpcClient = void 0;
// Integration toolkit for code generated by openapi-generator-javascript.
const lodash_1 = __importDefault(require("lodash"));
class JsonRpcClient {
    constructor(send) {
        this.send = send;
    }
    /* eslint-disable no-multi-spaces */
    callApi(_path, _httpMethod, _pathParams, _queryParams, _headerParams, _formParams, bodyParam, _authNames, _contentTypes, _accepts, _returnType, _apiBasePath, callback) {
        this.send(bodyParam.method, bodyParam.params)
            .then((data) => callback(null, data))
            .catch((err) => callback(err, null));
    }
}
exports.JsonRpcClient = JsonRpcClient;
function promisifyMethod(openApi, methodName, numRequiredArgs) {
    // API classes made by openapi-generator-javascript separately takes required and optional paramters,
    // and we have no definitive way to know the number of optional parameters.
    // So we only check for the number of required parameters, hence the condition args.length < numArgs.
    //
    // For instance klay_createAccessList has 1 required (callObject) and 1 'optional' (blockParameter) parameter.
    // The generated openApiMethod looks like this:
    //
    //   function createAccessList(callObject, opts, callback)
    //   - `callObject` is a required parameter.
    //   - `opts` contains optional parameters as an object `{blockParameter: 'latest'}` or an array `['latest']`.
    //
    // Here, the number of required parameters = (arg count) - (opts and callback) = 3 - 2 = 1 = numArgs
    // and the number of optional parameters is not known by JS Reflection.
    //
    // But because JSON-RPC API expects all parameters to be passed, the "optional" parameters are actually "required".
    //
    // For details, see the codegen frameworks
    //   https://github.com/klaytn/web3klaytn/blob/dev/web3rpc/sdk/client/javascript/template/libraries/javascript/api.mustache
    //   https://github.com/OpenAPITools/openapi-generator/blob/master/modules/openapi-generator/src/main/java/org/openapitools/codegen/languages/JavascriptClientCodegen.java
    // Or the generated code
    //   https://www.npmjs.com/package/@klaytn/web3rpc?activeTab=code
    //   @klaytn/web3rpc/dist/api/KlayApi.js
    return async function (...args) {
        if (args.length < numRequiredArgs) {
            throw new Error(`API ${String(methodName)} expects ${numRequiredArgs} or more arguments, got ${args.length}`);
        }
        const requiredArgs = args.slice(0, numRequiredArgs);
        const optionalArgs = args.slice(numRequiredArgs);
        return new Promise((resolve, reject) => {
            openApi[methodName](...requiredArgs, optionalArgs, (err, res) => {
                if (err) {
                    reject(err);
                }
                else {
                    resolve(res);
                }
            });
        });
    };
}
exports.promisifyMethod = promisifyMethod;
// promisifyApi converts NamespaceApi to AsyncNamespaceApi by promisifying each methods.
function promisifyApi(openApi) {
    const asyncApi = {};
    const proto = Reflect.getPrototypeOf(openApi);
    if (!proto) {
        throw new Error("Cannot promisify OpenApi object");
    }
    const methods = Reflect.ownKeys(proto);
    for (const methodName of methods) {
        // Assume the prototype has only constructor and API methods;
        // anything other that the constructor is an API method.
        if (methodName == "constructor") {
            continue;
        }
        const method = Reflect.get(proto, methodName);
        if (!lodash_1.default.isFunction(method)) {
            continue;
        }
        if (method.length < 2) {
            // Function.length is the number of arguments.
            // OpenApi generated methods have at least 2 arguments: opts, callback.
            continue;
        }
        // The openApiMethod looks like this: function api(req1, req2, opts, callback)
        const numRequiredArgs = method.length - 2;
        asyncApi[methodName] = promisifyMethod(openApi, methodName, numRequiredArgs);
    }
    return asyncApi;
}
exports.promisifyApi = promisifyApi;
function asyncOpenApi(send, Clazz) {
    const client = new JsonRpcClient(send);
    const api = new Clazz(client);
    return promisifyApi(api);
}
exports.asyncOpenApi = asyncOpenApi;
//# sourceMappingURL=openapi.js.map