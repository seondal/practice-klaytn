"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports["default"] = void 0;
var _ApiClient = _interopRequireDefault(require("../ApiClient"));
var _DeriveAccount200Response = _interopRequireDefault(require("../model/DeriveAccount200Response"));
var _DeriveAccountRequest = _interopRequireDefault(require("../model/DeriveAccountRequest"));
var _EcRecover200Response = _interopRequireDefault(require("../model/EcRecover200Response"));
var _EcRecoverRequest = _interopRequireDefault(require("../model/EcRecoverRequest"));
var _ImportRawKey200Response = _interopRequireDefault(require("../model/ImportRawKey200Response"));
var _ImportRawKeyRequest = _interopRequireDefault(require("../model/ImportRawKeyRequest"));
var _ListAccounts200Response = _interopRequireDefault(require("../model/ListAccounts200Response"));
var _ListAccountsRequest = _interopRequireDefault(require("../model/ListAccountsRequest"));
var _ListWallets200Response = _interopRequireDefault(require("../model/ListWallets200Response"));
var _ListWalletsRequest = _interopRequireDefault(require("../model/ListWalletsRequest"));
var _LockAccount200Response = _interopRequireDefault(require("../model/LockAccount200Response"));
var _LockAccountRequest = _interopRequireDefault(require("../model/LockAccountRequest"));
var _NewAccount200Response = _interopRequireDefault(require("../model/NewAccount200Response"));
var _NewAccountRequest = _interopRequireDefault(require("../model/NewAccountRequest"));
var _OpenWallet200Response = _interopRequireDefault(require("../model/OpenWallet200Response"));
var _OpenWalletRequest = _interopRequireDefault(require("../model/OpenWalletRequest"));
var _ReplaceRawKey200Response = _interopRequireDefault(require("../model/ReplaceRawKey200Response"));
var _ReplaceRawKeyRequest = _interopRequireDefault(require("../model/ReplaceRawKeyRequest"));
var _SendAccountUpdate200Response = _interopRequireDefault(require("../model/SendAccountUpdate200Response"));
var _SendAccountUpdateRequest = _interopRequireDefault(require("../model/SendAccountUpdateRequest"));
var _SendValueTransfer200Response = _interopRequireDefault(require("../model/SendValueTransfer200Response"));
var _SendValueTransferRequest = _interopRequireDefault(require("../model/SendValueTransferRequest"));
var _UnlockAccount200Response = _interopRequireDefault(require("../model/UnlockAccount200Response"));
var _UnlockAccountRequest = _interopRequireDefault(require("../model/UnlockAccountRequest"));
function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); } /**
 * web3rpc
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.9.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 *
 */
/**
* Personal service.
* @module api/PersonalApi
* @version 0.9.8
*/
var PersonalApi = exports["default"] = /*#__PURE__*/function () {
  /**
  * Constructs a new PersonalApi. 
  * @alias module:api/PersonalApi
  * @class
  * @param {module:ApiClient} [apiClient] Optional API client implementation to use,
  * default to {@link module:ApiClient#instance} if unspecified.
  */
  function PersonalApi(apiClient) {
    _classCallCheck(this, PersonalApi);
    this.apiClient = apiClient || _ApiClient["default"].instance;
  }

  /**
   * Callback function to receive the result of the deriveAccount operation.
   * @callback module:api/PersonalApi~deriveAccountCallback
   * @param {String} error Error message, if any.
   * @param {module:model/DeriveAccount200Response} data The data returned by the service call.
   * @param {String} response The complete HTTP response.
   */

  /**
   * [deriveAccount]
   * Requests a HD wallet to derive a new account, optionally pinning it for later reuse.  **JSONRPC:** `personal_deriveAccount` 
   * @param {String} URL Wallet url
   * @param {String} path derivation path
   * @param {Object} opts Optional parameters
   * @param {Boolean} opts.pin optionally pinning
   * @param {module:model/DeriveAccountRequest} opts.deriveAccountRequest 
   * @param {module:api/PersonalApi~deriveAccountCallback} callback The callback function, accepting three arguments: error, data, response
   * data is of type: {@link module:model/DeriveAccount200Response}
   */
  _createClass(PersonalApi, [{
    key: "deriveAccount",
    value: function deriveAccount(URL, path, opts, callback) {
      opts = opts || {};
      // verify the required parameter 'URL' is set
      if (URL === undefined || URL === null) {
        throw new Error("Missing the required parameter 'URL' when calling deriveAccount");
      }
      // verify the required parameter 'path' is set
      if (path === undefined || path === null) {
        throw new Error("Missing the required parameter 'path' when calling deriveAccount");
      }
      var postBody = new _DeriveAccountRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      postBody.params.push(URL);
      postBody.params.push(path);
      var defaultValue = null;
      var optParam = opts['pin'] || opts[optsIndex++] || defaultValue;
      if (optParam === undefined || optParam === null) {
        throw new Error("Missing the required parameter 'pin' when calling deriveAccount");
      }
      postBody.params.push(optParam);
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _DeriveAccount200Response["default"];
      return this.apiClient.callApi('/personal/deriveAccount', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the ecRecover operation.
     * @callback module:api/PersonalApi~ecRecoverCallback
     * @param {String} error Error message, if any.
     * @param {module:model/EcRecover200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [ecRecover]
     * ecRecover returns the address associated with the private key that was used to calculate the signature in personal_sign.  **JSONRPC:** `personal_ecRecover` 
     * @param {String} message A message.
     * @param {String} signature The signature.
     * @param {Object} opts Optional parameters
     * @param {module:model/EcRecoverRequest} opts.ecRecoverRequest 
     * @param {module:api/PersonalApi~ecRecoverCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/EcRecover200Response}
     */
  }, {
    key: "ecRecover",
    value: function ecRecover(message, signature, opts, callback) {
      opts = opts || {};
      // verify the required parameter 'message' is set
      if (message === undefined || message === null) {
        throw new Error("Missing the required parameter 'message' when calling ecRecover");
      }
      // verify the required parameter 'signature' is set
      if (signature === undefined || signature === null) {
        throw new Error("Missing the required parameter 'signature' when calling ecRecover");
      }
      var postBody = new _EcRecoverRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      postBody.params.push(message);
      postBody.params.push(signature);
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _EcRecover200Response["default"];
      return this.apiClient.callApi('/personal/ecRecover', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the importRawKey operation.
     * @callback module:api/PersonalApi~importRawKeyCallback
     * @param {String} error Error message, if any.
     * @param {module:model/ImportRawKey200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [importRawKey]
     * Imports the given unencrypted private key (hex string without leading '0x') or a Klaytn wallet key into the key store, encrypting it with the passphrase.  Returns the address of the imported account.  **JSONRPC:** `personal_importRawKey` 
     * @param {String} keydata The unencrypted private key (hex string without leading '0x') or a Klaytn wallet key.
     * @param {String} passphrase The pass phrase for encryption.
     * @param {Object} opts Optional parameters
     * @param {module:model/ImportRawKeyRequest} opts.importRawKeyRequest 
     * @param {module:api/PersonalApi~importRawKeyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/ImportRawKey200Response}
     */
  }, {
    key: "importRawKey",
    value: function importRawKey(keydata, passphrase, opts, callback) {
      opts = opts || {};
      // verify the required parameter 'keydata' is set
      if (keydata === undefined || keydata === null) {
        throw new Error("Missing the required parameter 'keydata' when calling importRawKey");
      }
      // verify the required parameter 'passphrase' is set
      if (passphrase === undefined || passphrase === null) {
        throw new Error("Missing the required parameter 'passphrase' when calling importRawKey");
      }
      var postBody = new _ImportRawKeyRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      postBody.params.push(keydata);
      postBody.params.push(passphrase);
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _ImportRawKey200Response["default"];
      return this.apiClient.callApi('/personal/importRawKey', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the listAccounts operation.
     * @callback module:api/PersonalApi~listAccountsCallback
     * @param {String} error Error message, if any.
     * @param {module:model/ListAccounts200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [listAccounts]
     * Returns all the Klaytn account addresses of all keys in the key store.  **JSONRPC:** `personal_listAccounts` 
     * @param {Object} opts Optional parameters
     * @param {module:model/ListAccountsRequest} opts.listAccountsRequest 
     * @param {module:api/PersonalApi~listAccountsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/ListAccounts200Response}
     */
  }, {
    key: "listAccounts",
    value: function listAccounts(opts, callback) {
      opts = opts || {};
      var postBody = new _ListAccountsRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _ListAccounts200Response["default"];
      return this.apiClient.callApi('/personal/listAccounts', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the listWallets operation.
     * @callback module:api/PersonalApi~listWalletsCallback
     * @param {String} error Error message, if any.
     * @param {module:model/ListWallets200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [listWallets]
     * Returns a list of wallets this node manages.  **JSONRPC:** `personal_listWallets` 
     * @param {Object} opts Optional parameters
     * @param {module:model/ListWalletsRequest} opts.listWalletsRequest 
     * @param {module:api/PersonalApi~listWalletsCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/ListWallets200Response}
     */
  }, {
    key: "listWallets",
    value: function listWallets(opts, callback) {
      opts = opts || {};
      var postBody = new _ListWalletsRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _ListWallets200Response["default"];
      return this.apiClient.callApi('/personal/listWallets', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the lockAccount operation.
     * @callback module:api/PersonalApi~lockAccountCallback
     * @param {String} error Error message, if any.
     * @param {module:model/LockAccount200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [lockAccount]
     * Removes the private key with a given address from memory. The account can no longer be used to send transactions.  **JSONRPC:** `personal_lockAccount` 
     * @param {String} address The account address to lock.
     * @param {Object} opts Optional parameters
     * @param {module:model/LockAccountRequest} opts.lockAccountRequest 
     * @param {module:api/PersonalApi~lockAccountCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/LockAccount200Response}
     */
  }, {
    key: "lockAccount",
    value: function lockAccount(address, opts, callback) {
      opts = opts || {};
      // verify the required parameter 'address' is set
      if (address === undefined || address === null) {
        throw new Error("Missing the required parameter 'address' when calling lockAccount");
      }
      var postBody = new _LockAccountRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      postBody.params.push(address);
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _LockAccount200Response["default"];
      return this.apiClient.callApi('/personal/lockAccount', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the newAccount operation.
     * @callback module:api/PersonalApi~newAccountCallback
     * @param {String} error Error message, if any.
     * @param {module:model/NewAccount200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [newAccount]
     * Generates a new private key and stores it in the key store directory. The key file is encrypted with the given passphrase. Returns the address of the new account.  At the Klaytn console, newAccount will prompt for a passphrase when it is not supplied as the argument.  **JSONRPC:** `personal_newAccount` 
     * @param {Object} opts Optional parameters
     * @param {String} opts.passphrase (optional) the pass phrase used for encryption.
     * @param {module:model/NewAccountRequest} opts.newAccountRequest 
     * @param {module:api/PersonalApi~newAccountCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/NewAccount200Response}
     */
  }, {
    key: "newAccount",
    value: function newAccount(opts, callback) {
      opts = opts || {};
      var postBody = new _NewAccountRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      var defaultValue = null;
      var optParam = opts['passphrase'] || opts[optsIndex++] || defaultValue;
      if (optParam === undefined || optParam === null) {
        throw new Error("Missing the required parameter 'passphrase' when calling newAccount");
      }
      postBody.params.push(optParam);
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _NewAccount200Response["default"];
      return this.apiClient.callApi('/personal/newAccount', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the openWallet operation.
     * @callback module:api/PersonalApi~openWalletCallback
     * @param {String} error Error message, if any.
     * @param {module:model/OpenWallet200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [openWallet]
     * Initiates a hardware wallet opening procedure, establishing a USB connection and attempting to authenticate via the provided passphrase.  **NOTE:** The method may return an extra challenge requiring a second open (e.g., the Trezor PIN matrix challenge).  **JSONRPC:** `personal_openWallet` 
     * @param {String} URL Wallet url
     * @param {String} passphrase passphrase for wallet
     * @param {Object} opts Optional parameters
     * @param {module:model/OpenWalletRequest} opts.openWalletRequest 
     * @param {module:api/PersonalApi~openWalletCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/OpenWallet200Response}
     */
  }, {
    key: "openWallet",
    value: function openWallet(URL, passphrase, opts, callback) {
      opts = opts || {};
      // verify the required parameter 'URL' is set
      if (URL === undefined || URL === null) {
        throw new Error("Missing the required parameter 'URL' when calling openWallet");
      }
      // verify the required parameter 'passphrase' is set
      if (passphrase === undefined || passphrase === null) {
        throw new Error("Missing the required parameter 'passphrase' when calling openWallet");
      }
      var postBody = new _OpenWalletRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      postBody.params.push(URL);
      postBody.params.push(passphrase);
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _OpenWallet200Response["default"];
      return this.apiClient.callApi('/personal/openWallet', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the replaceRawKey operation.
     * @callback module:api/PersonalApi~replaceRawKeyCallback
     * @param {String} error Error message, if any.
     * @param {module:model/ReplaceRawKey200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [replaceRawKey]
     * Replaces the encrypted key file in the key store with the given unencrypted private key (hex string without leading '0x') or a Klaytn wallet key, encrypting it with the new passphrase. It also receives the old passphrase to decrypt the old private key before replacement. If it is failed to decrypt, or can not find the matching account, it throws an error.  Returns the address of the replaced account if successful.  **JSONRPC:** `personal_replaceRawKey` 
     * @param {String} keydata The unencrypted private key (hex string without leading '0x') or a Klaytn wallet key.
     * @param {String} oldPassphrase The passphrase to decrypt the old private key.
     * @param {String} newPassphrase The passphrase to encrypt the new private key.
     * @param {Object} opts Optional parameters
     * @param {module:model/ReplaceRawKeyRequest} opts.replaceRawKeyRequest 
     * @param {module:api/PersonalApi~replaceRawKeyCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/ReplaceRawKey200Response}
     */
  }, {
    key: "replaceRawKey",
    value: function replaceRawKey(keydata, oldPassphrase, newPassphrase, opts, callback) {
      opts = opts || {};
      // verify the required parameter 'keydata' is set
      if (keydata === undefined || keydata === null) {
        throw new Error("Missing the required parameter 'keydata' when calling replaceRawKey");
      }
      // verify the required parameter 'oldPassphrase' is set
      if (oldPassphrase === undefined || oldPassphrase === null) {
        throw new Error("Missing the required parameter 'oldPassphrase' when calling replaceRawKey");
      }
      // verify the required parameter 'newPassphrase' is set
      if (newPassphrase === undefined || newPassphrase === null) {
        throw new Error("Missing the required parameter 'newPassphrase' when calling replaceRawKey");
      }
      var postBody = new _ReplaceRawKeyRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      postBody.params.push(keydata);
      postBody.params.push(oldPassphrase);
      postBody.params.push(newPassphrase);
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _ReplaceRawKey200Response["default"];
      return this.apiClient.callApi('/personal/replaceRawKey', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the sendAccountUpdate operation.
     * @callback module:api/PersonalApi~sendAccountUpdateCallback
     * @param {String} error Error message, if any.
     * @param {module:model/SendAccountUpdate200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [sendAccountUpdate]
     * Validates the given passphrase and submits a TxTypeAccountUpdate transaction. The transaction object must have fields from and key. Other fields such as gas, gasPrice, and nonce are se internally if unspecified. If the passphrase is able to decrypt the private key belonging to tx.from and the transaction is verified, the transaction is signed and submitted onto the network. The account is not unlocked globally in the node and cannot be used in other RPC calls.  **JSONRPC:** `personal_sendAccountUpdate` 
     * @param {String} tx A transaction object. from and key must be specified.
     * @param {String} passphrase The passphrase to decrypt the private key of tx.from.
     * @param {Object} opts Optional parameters
     * @param {module:model/SendAccountUpdateRequest} opts.sendAccountUpdateRequest 
     * @param {module:api/PersonalApi~sendAccountUpdateCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/SendAccountUpdate200Response}
     */
  }, {
    key: "sendAccountUpdate",
    value: function sendAccountUpdate(tx, passphrase, opts, callback) {
      opts = opts || {};
      // verify the required parameter 'tx' is set
      if (tx === undefined || tx === null) {
        throw new Error("Missing the required parameter 'tx' when calling sendAccountUpdate");
      }
      // verify the required parameter 'passphrase' is set
      if (passphrase === undefined || passphrase === null) {
        throw new Error("Missing the required parameter 'passphrase' when calling sendAccountUpdate");
      }
      var postBody = new _SendAccountUpdateRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      postBody.params.push(tx);
      postBody.params.push(passphrase);
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _SendAccountUpdate200Response["default"];
      return this.apiClient.callApi('/personal/sendAccountUpdate', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the sendValueTransfer operation.
     * @callback module:api/PersonalApi~sendValueTransferCallback
     * @param {String} error Error message, if any.
     * @param {module:model/SendValueTransfer200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [sendValueTransfer]
     * Validates the given passphrase and submits a TxTypeValueTransfer transaction. The transaction object must have fields from, to, and value. Other fields such as gas, gasPrice, and nonce are set internally if unspecified. If the passphrase is able to decrypt the private key belonging to tx.from and the transaction is verified, the transaction is signed and submitted onto the network. The account is not unlocked globally in the node and cannot be used in other RPC calls.  **JSONRPC:** `personal_sendValueTransfer` 
     * @param {String} tx A transaction object. from, to, and value must be specified.
     * @param {String} passphrase The passphrase to decrypt the private key of tx.from.
     * @param {Object} opts Optional parameters
     * @param {module:model/SendValueTransferRequest} opts.sendValueTransferRequest 
     * @param {module:api/PersonalApi~sendValueTransferCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/SendValueTransfer200Response}
     */
  }, {
    key: "sendValueTransfer",
    value: function sendValueTransfer(tx, passphrase, opts, callback) {
      opts = opts || {};
      // verify the required parameter 'tx' is set
      if (tx === undefined || tx === null) {
        throw new Error("Missing the required parameter 'tx' when calling sendValueTransfer");
      }
      // verify the required parameter 'passphrase' is set
      if (passphrase === undefined || passphrase === null) {
        throw new Error("Missing the required parameter 'passphrase' when calling sendValueTransfer");
      }
      var postBody = new _SendValueTransferRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      postBody.params.push(tx);
      postBody.params.push(passphrase);
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _SendValueTransfer200Response["default"];
      return this.apiClient.callApi('/personal/sendValueTransfer', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }

    /**
     * Callback function to receive the result of the unlockAccount operation.
     * @callback module:api/PersonalApi~unlockAccountCallback
     * @param {String} error Error message, if any.
     * @param {module:model/UnlockAccount200Response} data The data returned by the service call.
     * @param {String} response The complete HTTP response.
     */

    /**
     * [unlockAccount]
     * Decrypts the key with the given address from the key store.  Both passphrase and unlock duration are optional when using the JavaScript console. If the passphrase is not supplied as an argument, the console will prompt for the passphrase interactively.  The unencrypted key will be held in memory until the unlock duration expires. If the unlock duration defaults to 300 seconds. An explicit duration of zero seconds unlocks the key until the Klaytn local node exits.  The account can be used with klay_sign and klay_sendTransaction while it is unlocked.  **JSONRPC:** `personal_unlockAccount` 
     * @param {String} address The account address to unlock.
     * @param {String} passphrase the passphrase used for the encryption.
     * @param {Object} opts Optional parameters
     * @param {Number} opts.duration (optional) the unlock duration (default to 300 seconds). (default to 300)
     * @param {module:model/UnlockAccountRequest} opts.unlockAccountRequest 
     * @param {module:api/PersonalApi~unlockAccountCallback} callback The callback function, accepting three arguments: error, data, response
     * data is of type: {@link module:model/UnlockAccount200Response}
     */
  }, {
    key: "unlockAccount",
    value: function unlockAccount(address, passphrase, opts, callback) {
      opts = opts || {};
      // verify the required parameter 'address' is set
      if (address === undefined || address === null) {
        throw new Error("Missing the required parameter 'address' when calling unlockAccount");
      }
      // verify the required parameter 'passphrase' is set
      if (passphrase === undefined || passphrase === null) {
        throw new Error("Missing the required parameter 'passphrase' when calling unlockAccount");
      }
      var postBody = new _UnlockAccountRequest["default"](undefined, undefined, undefined);
      var optsIndex = 0;
      postBody.params = [];
      postBody.params.push(address);
      postBody.params.push(passphrase);
      var defaultValue = null;
      var optParam = opts['duration'] || opts[optsIndex++] || defaultValue;
      if (optParam === undefined || optParam === null) {
        throw new Error("Missing the required parameter 'duration' when calling unlockAccount");
      }
      postBody.params.push(optParam);
      var authNames = [];
      var contentTypes = ['application/json'];
      var accepts = ['application/json'];
      var returnType = _UnlockAccount200Response["default"];
      return this.apiClient.callApi('/personal/unlockAccount', 'POST', null, null, null, null, postBody, authNames, contentTypes, accepts, returnType, null, callback);
    }
  }]);
  return PersonalApi;
}();