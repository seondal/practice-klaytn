import { Provider, TransactionRequest, TransactionResponse } from "@ethersproject/abstract-provider";
import { ExternallyOwnedAccount } from "@ethersproject/abstract-signer";
import { Wallet as EthersWallet } from "@ethersproject/wallet";
import { Bytes, BytesLike, Deferrable, ProgressCallback, SigningKey } from "ethers/lib/utils";
type PrivateKeyLike = BytesLike | ExternallyOwnedAccount | SigningKey;
export declare class Wallet extends EthersWallet {
    static fromEncryptedJson(json: string, password: string | Bytes, progress?: ProgressCallback): Promise<Wallet>;
    static fromEncryptedJsonSync(json: string, password: string | Bytes): Wallet;
    static fromEncryptedJsonList(json: string, password: string | Bytes, progress?: ProgressCallback): Promise<Wallet[]>;
    static fromEncryptedJsonListSync(json: string, password: string | Bytes): Wallet[];
    private klaytnAddr;
    constructor(addressOrPrivateKey: string | PrivateKeyLike, privateKeyOrProvider?: PrivateKeyLike | Provider, provider?: Provider);
    getAddress(legacy?: boolean): Promise<string>;
    getEtherAddress(): Promise<string>;
    isDecoupled(): Promise<boolean>;
    checkTransaction(transaction: Deferrable<TransactionRequest>): Deferrable<TransactionRequest>;
    populateTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionRequest>;
    decodeTxFromRLP(rlp: string): any;
    signTransaction(transaction: Deferrable<TransactionRequest>): Promise<string>;
    signTransactionAsFeePayer(transaction: Deferrable<TransactionRequest>): Promise<string>;
    sendTransaction(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse>;
    sendTransactionAsFeePayer(transaction: Deferrable<TransactionRequest>): Promise<TransactionResponse>;
    _eip155sign(digest: string, chainId?: number): import("ethers").Signature;
    _chainIdFromTx(tx: any): Promise<number | undefined>;
    _sendRawTransaction(signedTx: string): Promise<TransactionResponse>;
}
export {};
//# sourceMappingURL=signer.d.ts.map