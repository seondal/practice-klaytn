"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.FieldSetFactory = exports.FieldSet = void 0;
const lodash_1 = __importDefault(require("lodash"));
const util_1 = require("../util");
class FieldSet {
    constructor() {
        // End override
        // //////////////////////////////////////////////////////////
        // shortcuts for this._static.*.
        this.type = -1;
        this.typeName = "";
        this.fieldTypes = {};
        // Fields in their canonical forms.
        this.fields = {};
        this.type = this._static.type;
        this.typeName = this._static.typeName;
        this.fieldTypes = this._static.fieldTypes;
    }
    // A workaround to read child class's static members.
    get _static() {
        return this.constructor;
    }
    // Fields accessors
    // Reset all fields from an object
    setFields(obj) {
        this.fields = {};
        lodash_1.default.forOwn(this.fieldTypes, (fieldType, name) => {
            if (obj[name] === undefined) {
                this.fields[name] = null;
                return;
            }
            try {
                this.fields[name] = fieldType.canonicalize(obj[name]);
            }
            catch (e) {
                throw new Error(`Cannot set field '${name}' to '${JSON.stringify(obj[name])}': ${e}`);
            }
        });
    }
    // Reset all fields from the array
    setFieldsFromArray(names, array) {
        this.fields = {};
        for (let i = 0; i < array.length; i++) {
            const name = names[i];
            const fieldType = this.fieldTypes[name];
            if (!fieldType) {
                throw new Error(`Unknown field '${name}' for '${this.typeName}' (type ${this.type})`);
            }
            try {
                this.fields[name] = fieldType.canonicalize(array[i]);
            }
            catch (e) {
                throw new Error(`Cannot set field '${name}' to '${JSON.stringify(array[i])}': ${e}`);
            }
        }
    }
    // Get one field
    getField(name) {
        const value = this.fields[name];
        if (value == null) {
            throw new Error(`Missing field '${name}' for '${this.typeName}' (type ${this.type})`);
        }
        return value;
    }
    // Get many fields as an array
    getFields(names) {
        return lodash_1.default.map(names, (name) => this.getField(name));
    }
    toObject() {
        return this.fields;
    }
}
exports.FieldSet = FieldSet;
// //////////////////////////////////////////////////////////
// Child classes MUST override below properties and methods
// An 1-byte type enum
FieldSet.type = -1;
class FieldSetFactory {
    constructor(requiredFields) {
        this.registry = {};
        this.requiredFields = requiredFields || [];
    }
    add(cls) {
        const type = cls.type;
        const fieldTypes = cls.fieldTypes;
        if (type === -1) {
            throw new Error("Cannot register TypedFields: Missing type");
        }
        if (this.registry[type]) {
            throw new Error(`Cannot register TypedFields: type ${type} already registered`);
        }
        if (!fieldTypes) {
            throw new Error("Cannot register TypedFields: Missing fieldTypes");
        }
        for (const name of this.requiredFields) {
            if (!fieldTypes[name]) {
                throw new Error(`Cannot register TypedFields: Missing required field '${name}'`);
            }
        }
        this.registry[type] = cls;
    }
    has(type) {
        if (util_1.HexStr.isHex(type)) {
            return lodash_1.default.has(this.registry, util_1.HexStr.toNumber(type));
        }
        else {
            return lodash_1.default.has(this.registry, type);
        }
    }
    lookup(type) {
        if (!this.has(type)) {
            throw new Error(`Unsupported type '${util_1.HexStr.fromNumber(type)}'`);
        }
        if (util_1.HexStr.isHex(type)) {
            return this.registry[util_1.HexStr.toNumber(type)];
        }
        else {
            return this.registry[type];
        }
    }
    fromObject(fields) {
        const ctor = this.lookup(fields === null || fields === void 0 ? void 0 : fields.type);
        const instance = new ctor();
        instance.setFields(fields);
        return instance;
    }
}
exports.FieldSetFactory = FieldSetFactory;
//# sourceMappingURL=fieldset.js.map